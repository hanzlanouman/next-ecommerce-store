"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cloudinary-core";
exports.ids = ["vendor-chunks/cloudinary-core"];
exports.modules = {

/***/ "(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.0\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\"; // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1; //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                } // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\"; // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer); // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\")); // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\"); // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                } // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, _typeof(obj);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    } // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, baseutil_typeof(obj);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type; // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            }; // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            }; // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            }; // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    } // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width; // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                } // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val; // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox; // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    } // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name]; // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                } // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\"; // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            }); // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n                return Expression;\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, condition_typeof(obj);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            function _createSuper(Derived) {\n                var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = _getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = _getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return _possibleConstructorReturn(this, result);\n                };\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                _inherits(Condition, _Expression);\n                var _super = _createSuper(Condition);\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _super.call(this, conditionStr);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n                return Condition;\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n                return Configuration;\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n                return Layer1;\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, textlayer_typeof(obj);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            function textlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = textlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = textlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = textlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return textlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                textlayer_inherits(TextLayer, _Layer);\n                var _super = textlayer_createSuper(TextLayer);\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = _super.call(this, options);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0; //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n                return TextLayer;\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, subtitleslayer_typeof(obj);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            function subtitleslayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = subtitleslayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = subtitleslayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = subtitleslayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return subtitleslayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                var _super = subtitleslayer_createSuper(SubtitlesLayer);\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = _super.call(this, options);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, fetchlayer_typeof(obj);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            function fetchlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = fetchlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = fetchlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = fetchlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return fetchlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                fetchlayer_inherits(FetchLayer, _Layer);\n                var _super = fetchlayer_createSuper(FetchLayer);\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = _super.call(this, options);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n                return FetchLayer;\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, parameters_typeof(obj);\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_createSuper(Derived) {\n                var hasNativeReflectConstruct = parameters_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = parameters_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = parameters_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return parameters_possibleConstructorReturn(this, result);\n                };\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n                return Param;\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                parameters_inherits(ArrayParam, _Param);\n                var _super = parameters_createSuper(ArrayParam);\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = _super.call(this, name, shortName, process1);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return ArrayParam;\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                parameters_inherits(TransformationParam, _Param2);\n                var _super2 = parameters_createSuper(TransformationParam);\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = _super2.call(this, name, shortName, process1);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            } // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return TransformationParam;\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                parameters_inherits(RangeParam, _Param3);\n                var _super3 = parameters_createSuper(RangeParam);\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return _super3.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n                return RangeParam;\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                parameters_inherits(RawParam, _Param4);\n                var _super4 = parameters_createSuper(RawParam);\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return _super4.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n                return RawParam;\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                parameters_inherits(LayerParam, _Param5);\n                var _super5 = parameters_createSuper(LayerParam);\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return _super5.apply(this, arguments);\n                }\n                parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n                return LayerParam;\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                parameters_inherits(ExpressionParam, _Param6);\n                var _super6 = parameters_createSuper(ExpressionParam);\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return _super6.apply(this, arguments);\n                }\n                parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n                return ExpressionParam;\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, transformation_typeof(obj);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_createSuper(Derived) {\n                var hasNativeReflectConstruct = transformation_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = transformation_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = transformation_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return transformation_possibleConstructorReturn(this, result);\n                };\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    }; // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    }; // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                }); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            }); // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n                return TransformationBase;\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                transformation_inherits(Transformation, _TransformationBase);\n                var _super = transformation_createSuper(Transformation);\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return _super.call(this, options);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n                return Transformation;\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n                return HtmlTag;\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            } // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                } // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name; // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\"; // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions); // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                } // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions); // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, imagetag_typeof(obj);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            function imagetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = imagetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = imagetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = imagetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return imagetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                imagetag_inherits(ImageTag, _HtmlTag);\n                var _super = imagetag_createSuper(ImageTag);\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return _super.call(this, \"img\", publicId, options);\n                }\n                /** @override */ imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return ImageTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, sourcetag_typeof(obj);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            function sourcetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = sourcetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = sourcetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = sourcetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return sourcetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                sourcetag_inherits(SourceTag, _HtmlTag);\n                var _super = sourcetag_createSuper(SourceTag);\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return _super.call(this, \"source\", publicId, options);\n                }\n                /** @override */ sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return SourceTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, picturetag_typeof(obj);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            function picturetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = picturetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = picturetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = picturetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return picturetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                picturetag_inherits(PictureTag, _HtmlTag);\n                var _super = picturetag_createSuper(PictureTag);\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = _super.call(this, \"picture\", publicId, options);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n                return PictureTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, videotag_typeof(obj);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            function videotag_createSuper(Derived) {\n                var hasNativeReflectConstruct = videotag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = videotag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = videotag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return videotag_possibleConstructorReturn(this, result);\n                };\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                videotag_inherits(VideoTag, _HtmlTag);\n                var _super = videotag_createSuper(VideoTag);\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return _super.call(this, \"video\", publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"), options);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\"); // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n                return VideoTag;\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, clienthintsmetatag_typeof(obj);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            function clienthintsmetatag_createSuper(Derived) {\n                var hasNativeReflectConstruct = clienthintsmetatag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = clienthintsmetatag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = clienthintsmetatag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return clienthintsmetatag_possibleConstructorReturn(this, result);\n                };\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                var _super = clienthintsmetatag_createSuper(ClientHintsMetaTag);\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return _super.call(this, \"meta\", void 0, assign_root_assign_default()({\n                        \"http-equiv\": \"Accept-CH\",\n                        content: \"DPR, Viewport-Width, Width\"\n                    }, options));\n                }\n                /** @override */ clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return ClientHintsMetaTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml(); // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                } // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject); // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster); // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID); // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass; // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            }); // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        }); // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options); // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options)); // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    }); // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n                return Cloudinary;\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbG91ZGluYXJ5LWNvcmUvY2xvdWRpbmFyeS1jb3JlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUcsR0FDRixVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLG9DQUFlLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHNDQUFnQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLGtEQUFzQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsa0NBQWMsR0FBR0EsbUJBQU9BLENBQUMsZ0NBQWE7U0FDM1osRUFLNFY7QUFDbFcsR0FBRyxRQUFNLFNBQVNHLHlDQUF5QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMENBQTBDLEVBQUVDLDZDQUE2QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMkNBQTJDLEVBQUVDLDJDQUEyQyxFQUFFQywwQ0FBMEMsRUFBRUMsNENBQTRDLEVBQUVDLDZDQUE2QyxFQUFFQyxnREFBZ0QsRUFBRUMsMkNBQTJDLEVBQUVDLHdDQUF3QyxFQUFFQyx1Q0FBdUM7SUFDdm9CLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQywrQkFB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TyxHQUFHaUI7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLGVBQ04sR0FBRyxHQUFJLFNBQVNoQixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2tCO1FBRWpCLEdBQUcsR0FBRztJQUVHO0FBQ1QsSUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWVjb21tLy4vbm9kZV9tb2R1bGVzL2Nsb3VkaW5hcnktY29yZS9jbG91ZGluYXJ5LWNvcmUuanM/ZjczYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogY2xvdWRpbmFyeS1jb3JlLmpzXG4gICAqIENsb3VkaW5hcnkncyBKYXZhU2NyaXB0IGxpYnJhcnkgLSBWZXJzaW9uIDIuMTMuMFxuICAgKiBDb3B5cmlnaHQgQ2xvdWRpbmFyeVxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaW5hcnkvY2xvdWRpbmFyeV9qc1xuICAgKlxuICAgKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLCByZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSwgcmVxdWlyZShcImxvZGFzaC9mdW5jdGlvbnNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaWRlbnRpdHlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNBcnJheVwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0VsZW1lbnRcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpLCByZXF1aXJlKFwibG9kYXNoL21lcmdlXCIpLCByZXF1aXJlKFwibG9kYXNoL3RyaW1cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibG9kYXNoL2Fzc2lnblwiLCBcImxvZGFzaC9jbG9uZURlZXBcIiwgXCJsb2Rhc2gvY29tcGFjdFwiLCBcImxvZGFzaC9kaWZmZXJlbmNlXCIsIFwibG9kYXNoL2Z1bmN0aW9uc1wiLCBcImxvZGFzaC9pZGVudGl0eVwiLCBcImxvZGFzaC9pbmNsdWRlc1wiLCBcImxvZGFzaC9pc0FycmF5XCIsIFwibG9kYXNoL2lzRWxlbWVudFwiLCBcImxvZGFzaC9pc0Z1bmN0aW9uXCIsIFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiwgXCJsb2Rhc2gvaXNTdHJpbmdcIiwgXCJsb2Rhc2gvbWVyZ2VcIiwgXCJsb2Rhc2gvdHJpbVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjbG91ZGluYXJ5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSwgcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIiksIHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpLCByZXF1aXJlKFwibG9kYXNoL2Z1bmN0aW9uc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pZGVudGl0eVwiKSwgcmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRWxlbWVudFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIiksIHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvdHJpbVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY2xvdWRpbmFyeVwiXSA9IGZhY3Rvcnkocm9vdFtcIl9cIl1bXCJhc3NpZ25cIl0sIHJvb3RbXCJfXCJdW1wiY2xvbmVEZWVwXCJdLCByb290W1wiX1wiXVtcImNvbXBhY3RcIl0sIHJvb3RbXCJfXCJdW1wiZGlmZmVyZW5jZVwiXSwgcm9vdFtcIl9cIl1bXCJmdW5jdGlvbnNcIl0sIHJvb3RbXCJfXCJdW1wiaWRlbnRpdHlcIl0sIHJvb3RbXCJfXCJdW1wiaW5jbHVkZXNcIl0sIHJvb3RbXCJfXCJdW1wiaXNBcnJheVwiXSwgcm9vdFtcIl9cIl1bXCJpc0VsZW1lbnRcIl0sIHJvb3RbXCJfXCJdW1wiaXNGdW5jdGlvblwiXSwgcm9vdFtcIl9cIl1bXCJpc1BsYWluT2JqZWN0XCJdLCByb290W1wiX1wiXVtcImlzU3RyaW5nXCJdLCByb290W1wiX1wiXVtcIm1lcmdlXCJdLCByb290W1wiX1wiXVtcInRyaW1cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Nsb25lRGVlcF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2RpZmZlcmVuY2VfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRnVuY3Rpb25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNQbGFpbk9iamVjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9tZXJnZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsaWVudEhpbnRzTWV0YVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNsaWVudGhpbnRzbWV0YXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbG91ZGluYXJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY2xvdWRpbmFyeTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb25kaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjb25kaXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29uZmlndXJhdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY19jb25maWd1cmF0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyYzMyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX2NyYzMyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkV4cHJlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBleHByZXNzaW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkZldGNoTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBmZXRjaGxheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkh0bWxUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBodG1sdGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkltYWdlVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gaW1hZ2V0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBsYXllcl9sYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQaWN0dXJlVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gcGljdHVyZXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTdWJ0aXRsZXNMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHN1YnRpdGxlc2xheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRleHRMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHRleHRsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUcmFuc2Zvcm1hdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY190cmFuc2Zvcm1hdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1dGY4X2VuY29kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY191dGY4X2VuY29kZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJVdGlsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gbG9kYXNoX25hbWVzcGFjZU9iamVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWaWRlb1RhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHZpZGVvdGFnOyB9KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9zcmMvY29uc3RhbnRzLmpzXG52YXIgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiVkVSU0lPTlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZFUlNJT047IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQ0ZfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENGX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT0xEX0FLQU1BSV9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkFLQU1BSV9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUtBTUFJX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9USU1FT1VUX01TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9USU1FT1VUX01TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfUE9TVEVSX09QVElPTlNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1BPU1RFUl9PUFRJT05TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiU0VPX1RZUEVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0VPX1RZUEVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfSU1BR0VfUEFSQU1TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9JTUFHRV9QQVJBTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19QQVJBTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1BBUkFNUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1NPVVJDRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1NPVVJDRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJQTEFDRUhPTERFUl9JTUFHRV9NT0RFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBMQUNFSE9MREVSX0lNQUdFX01PREVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkFDQ0VTU0lCSUxJVFlfTU9ERVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBQ0NFU1NJQklMSVRZX01PREVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlVSTF9LRVlTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMX0tFWVM7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy91dGlsL2xvZGFzaC5qc1xudmFyIGxvZGFzaF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFNES0FuYWx5dGljc1NpZ25hdHVyZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFNES0FuYWx5dGljc1NpZ25hdHVyZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRBbmFseXRpY3NPcHRpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0QW5hbHl0aWNzT3B0aW9uczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhc3NpZ25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNsb25lRGVlcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29tcGFjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkaWZmZXJlbmNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImZ1bmN0aW9uc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaWRlbnRpdHlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpbmNsdWRlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNQbGFpbk9iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1N0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm1lcmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29udGFpbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkZXRlY3RJbnRlcnNlY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZXRlY3RJbnRlcnNlY3Rpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib21pdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9taXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYWxsU3RyaW5nc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2V1dGlsX2FsbFN0cmluZ3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aG91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhvdXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNOdW1iZXJMaWtlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNOdW1iZXJMaWtlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNtYXJ0RXNjYXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc21hcnRFc2NhcGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGVmYXVsdHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWZhdWx0czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvYmplY3RQcm90b1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9iamVjdFByb3RvOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9ialRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqVG9TdHJpbmc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc09iamVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJmdW5jVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY1RhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJyZVdvcmRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVXb3JkczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjYW1lbENhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW1lbENhc2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic25ha2VDYXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc25ha2VDYXNlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbnZlcnRLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udmVydEtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aENhbWVsQ2FzZUtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRoQ2FtZWxDYXNlS2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRoU25ha2VDYXNlS2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhTbmFrZUNhc2VLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImJhc2U2NEVuY29kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2U2NEVuY29kZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJiYXNlNjRFbmNvZGVVUkxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNlNjRFbmNvZGVVUkw7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZXh0cmFjdFVybFBhcmFtc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV4dHJhY3RVcmxQYXJhbXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicGF0Y2hGZXRjaEZvcm1hdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhdGNoRmV0Y2hGb3JtYXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib3B0aW9uQ29uc3VtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbkNvbnN1bWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFbXB0eVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRW1wdHk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNBbmRyb2lkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNBbmRyb2lkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRWRnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRWRnZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0Nocm9tZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ2hyb21lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzU2FmYXJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTYWZhcmk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFbGVtZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0Z1bmN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInRyaW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0RGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9nZXREYXRhOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfc2V0RGF0YTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfZ2V0QXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldEF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9zZXRBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicmVtb3ZlQXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXRBdHRyaWJ1dGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0QXR0cmlidXRlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJoYXNDbGFzc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9oYXNDbGFzczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhZGRDbGFzc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9hZGRDbGFzczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRTdHlsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTdHlsZXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3NzRXhwYW5kXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3NzRXhwYW5kOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRvbVN0eWxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZG9tU3R5bGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3VyQ1NTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VyQ1NTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNzc1ZhbHVlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3NzVmFsdWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYXVnbWVudFdpZHRoT3JIZWlnaHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdWdtZW50V2lkdGhPckhlaWdodDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRXaWR0aE9ySGVpZ2h0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2lkdGhPckhlaWdodDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aWR0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF93aWR0aDsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0ZjhfZW5jb2RlLmpzXG4vKipcbiAqIFVURjggZW5jb2RlclxuICogQHByaXZhdGVcbiAqL1xudmFyIHV0ZjhfZW5jb2RlO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3V0ZjhfZW5jb2RlID0gKHV0ZjhfZW5jb2RlID0gZnVuY3Rpb24gdXRmOF9lbmNvZGUoYXJnU3RyaW5nKSB7XG4gIHZhciBjMSwgZW5jLCBlbmQsIG4sIHN0YXJ0LCBzdHJpbmcsIHN0cmluZ2wsIHV0ZnRleHQ7IC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gIC8vICsgICBvcmlnaW5hbCBieTogV2VidG9vbGtpdC5pbmZvIChodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby8pXG4gIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gIC8vICsgICBpbXByb3ZlZCBieTogc293YmVycnlcbiAgLy8gKyAgICB0d2Vha2VkIGJ5OiBKYWNrXG4gIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gIC8vICsgICBpbXByb3ZlZCBieTogWXZlcyBTdWNhZXRcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBVbHJpY2hcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBSYWZhbCBLdWthd3NraVxuICAvLyArICAgaW1wcm92ZWQgYnk6IGtpcmlsbG9pZFxuICAvLyAqICAgICBleGFtcGxlIDE6IHV0ZjhfZW5jb2RlKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG5cbiAgaWYgKGFyZ1N0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnU3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHN0cmluZyA9IGFyZ1N0cmluZyArICcnOyAvLyAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKTtcblxuICB1dGZ0ZXh0ID0gJyc7XG4gIHN0YXJ0ID0gdm9pZCAwO1xuICBlbmQgPSB2b2lkIDA7XG4gIHN0cmluZ2wgPSAwO1xuICBzdGFydCA9IGVuZCA9IDA7XG4gIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuICBuID0gMDtcblxuICB3aGlsZSAobiA8IHN0cmluZ2wpIHtcbiAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgIGVuYyA9IG51bGw7XG5cbiAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgIGVuZCsrO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAxMjcgJiYgYzEgPCAyMDQ4KSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDYgfCAxOTIsIGMxICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDEyIHwgMjI0LCBjMSA+PiA2ICYgNjMgfCAxMjgsIGMxICYgNjMgfCAxMjgpO1xuICAgIH1cblxuICAgIGlmIChlbmMgIT09IG51bGwpIHtcbiAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgIH1cblxuICAgIG4rKztcbiAgfVxuXG4gIGlmIChlbmQgPiBzdGFydCkge1xuICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBzdHJpbmdsKTtcbiAgfVxuXG4gIHJldHVybiB1dGZ0ZXh0O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jcmMzMi5qc1xuXG4vKipcbiAqIENSQzMyIGNhbGN1bGF0b3JcbiAqIERlcGVuZHMgb24gJ3V0ZjhfZW5jb2RlJ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGNhbGN1bGF0ZSB0aGUgQ1JDMzIgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGNyYzMyKHN0cikge1xuICB2YXIgY3JjLCBpLCBpVG9wLCB0YWJsZSwgeCwgeTsgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUMGJzblxuICAvLyArICAgaW1wcm92ZWQgYnk6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY0NzkzNS9qYXZhc2NyaXB0LWNyYzMyLWZ1bmN0aW9uLWFuZC1waHAtY3JjMzItbm90LW1hdGNoaW5nXG4gIC8vIC0gICAgZGVwZW5kcyBvbjogdXRmOF9lbmNvZGVcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBjcmMzMignS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IDEyNDk5OTEyNDlcblxuICBzdHIgPSBzcmNfdXRmOF9lbmNvZGUoc3RyKTtcbiAgdGFibGUgPSAnMDAwMDAwMDAgNzcwNzMwOTYgRUUwRTYxMkMgOTkwOTUxQkEgMDc2REM0MTkgNzA2QUY0OEYgRTk2M0E1MzUgOUU2NDk1QTMgMEVEQjg4MzIgNzlEQ0I4QTQgRTBENUU5MUUgOTdEMkQ5ODggMDlCNjRDMkIgN0VCMTdDQkQgRTdCODJEMDcgOTBCRjFEOTEgMURCNzEwNjQgNkFCMDIwRjIgRjNCOTcxNDggODRCRTQxREUgMUFEQUQ0N0QgNkREREU0RUIgRjRENEI1NTEgODNEMzg1QzcgMTM2Qzk4NTYgNjQ2QkE4QzAgRkQ2MkY5N0EgOEE2NUM5RUMgMTQwMTVDNEYgNjMwNjZDRDkgRkEwRjNENjMgOEQwODBERjUgM0I2RTIwQzggNEM2OTEwNUUgRDU2MDQxRTQgQTI2NzcxNzIgM0MwM0U0RDEgNEIwNEQ0NDcgRDIwRDg1RkQgQTUwQUI1NkIgMzVCNUE4RkEgNDJCMjk4NkMgREJCQkM5RDYgQUNCQ0Y5NDAgMzJEODZDRTMgNDVERjVDNzUgRENENjBEQ0YgQUJEMTNENTkgMjZEOTMwQUMgNTFERTAwM0EgQzhENzUxODAgQkZEMDYxMTYgMjFCNEY0QjUgNTZCM0M0MjMgQ0ZCQTk1OTkgQjhCREE1MEYgMjgwMkI4OUUgNUYwNTg4MDggQzYwQ0Q5QjIgQjEwQkU5MjQgMkY2RjdDODcgNTg2ODRDMTEgQzE2MTFEQUIgQjY2NjJEM0QgNzZEQzQxOTAgMDFEQjcxMDYgOThEMjIwQkMgRUZENTEwMkEgNzFCMTg1ODkgMDZCNkI1MUYgOUZCRkU0QTUgRThCOEQ0MzMgNzgwN0M5QTIgMEYwMEY5MzQgOTYwOUE4OEUgRTEwRTk4MTggN0Y2QTBEQkIgMDg2RDNEMkQgOTE2NDZDOTcgRTY2MzVDMDEgNkI2QjUxRjQgMUM2QzYxNjIgODU2NTMwRDggRjI2MjAwNEUgNkMwNjk1RUQgMUIwMUE1N0IgODIwOEY0QzEgRjUwRkM0NTcgNjVCMEQ5QzYgMTJCN0U5NTAgOEJCRUI4RUEgRkNCOTg4N0MgNjJERDFEREYgMTVEQTJENDkgOENEMzdDRjMgRkJENDRDNjUgNERCMjYxNTggM0FCNTUxQ0UgQTNCQzAwNzQgRDRCQjMwRTIgNEFERkE1NDEgM0REODk1RDcgQTREMUM0NkQgRDNENkY0RkIgNDM2OUU5NkEgMzQ2RUQ5RkMgQUQ2Nzg4NDYgREE2MEI4RDAgNDQwNDJENzMgMzMwMzFERTUgQUEwQTRDNUYgREQwRDdDQzkgNTAwNTcxM0MgMjcwMjQxQUEgQkUwQjEwMTAgQzkwQzIwODYgNTc2OEI1MjUgMjA2Rjg1QjMgQjk2NkQ0MDkgQ0U2MUU0OUYgNUVERUY5MEUgMjlEOUM5OTggQjBEMDk4MjIgQzdEN0E4QjQgNTlCMzNEMTcgMkVCNDBEODEgQjdCRDVDM0IgQzBCQTZDQUQgRURCODgzMjAgOUFCRkIzQjYgMDNCNkUyMEMgNzRCMUQyOUEgRUFENTQ3MzkgOUREMjc3QUYgMDREQjI2MTUgNzNEQzE2ODMgRTM2MzBCMTIgOTQ2NDNCODQgMEQ2RDZBM0UgN0E2QTVBQTggRTQwRUNGMEIgOTMwOUZGOUQgMEEwMEFFMjcgN0QwNzlFQjEgRjAwRjkzNDQgODcwOEEzRDIgMUUwMUYyNjggNjkwNkMyRkUgRjc2MjU3NUQgODA2NTY3Q0IgMTk2QzM2NzEgNkU2QjA2RTcgRkVENDFCNzYgODlEMzJCRTAgMTBEQTdBNUEgNjdERDRBQ0MgRjlCOURGNkYgOEVCRUVGRjkgMTdCN0JFNDMgNjBCMDhFRDUgRDZENkEzRTggQTFEMTkzN0UgMzhEOEMyQzQgNEZERkYyNTIgRDFCQjY3RjEgQTZCQzU3NjcgM0ZCNTA2REQgNDhCMjM2NEIgRDgwRDJCREEgQUYwQTFCNEMgMzYwMzRBRjYgNDEwNDdBNjAgREY2MEVGQzMgQTg2N0RGNTUgMzE2RThFRUYgNDY2OUJFNzkgQ0I2MUIzOEMgQkM2NjgzMUEgMjU2RkQyQTAgNTI2OEUyMzYgQ0MwQzc3OTUgQkIwQjQ3MDMgMjIwMjE2QjkgNTUwNTI2MkYgQzVCQTNCQkUgQjJCRDBCMjggMkJCNDVBOTIgNUNCMzZBMDQgQzJEN0ZGQTcgQjVEMENGMzEgMkNEOTlFOEIgNUJERUFFMUQgOUI2NEMyQjAgRUM2M0YyMjYgNzU2QUEzOUMgMDI2RDkzMEEgOUMwOTA2QTkgRUIwRTM2M0YgNzIwNzY3ODUgMDUwMDU3MTMgOTVCRjRBODIgRTJCODdBMTQgN0JCMTJCQUUgMENCNjFCMzggOTJEMjhFOUIgRTVENUJFMEQgN0NEQ0VGQjcgMEJEQkRGMjEgODZEM0QyRDQgRjFENEUyNDIgNjhEREIzRjggMUZEQTgzNkUgODFCRTE2Q0QgRjZCOTI2NUIgNkZCMDc3RTEgMThCNzQ3NzcgODgwODVBRTYgRkYwRjZBNzAgNjYwNjNCQ0EgMTEwMTBCNUMgOEY2NTlFRkYgRjg2MkFFNjkgNjE2QkZGRDMgMTY2Q0NGNDUgQTAwQUUyNzggRDcwREQyRUUgNEUwNDgzNTQgMzkwM0IzQzIgQTc2NzI2NjEgRDA2MDE2RjcgNDk2OTQ3NEQgM0U2RTc3REIgQUVEMTZBNEEgRDlENjVBREMgNDBERjBCNjYgMzdEODNCRjAgQTlCQ0FFNTMgREVCQjlFQzUgNDdCMkNGN0YgMzBCNUZGRTkgQkRCREYyMUMgQ0FCQUMyOEEgNTNCMzkzMzAgMjRCNEEzQTYgQkFEMDM2MDUgQ0RENzA2OTMgNTRERTU3MjkgMjNEOTY3QkYgQjM2NjdBMkUgQzQ2MTRBQjggNUQ2ODFCMDIgMkE2RjJCOTQgQjQwQkJFMzcgQzMwQzhFQTEgNUEwNURGMUIgMkQwMkVGOEQnO1xuICBjcmMgPSAwO1xuICB4ID0gMDtcbiAgeSA9IDA7XG4gIGNyYyA9IGNyYyBeIC0xO1xuICBpID0gMDtcbiAgaVRvcCA9IHN0ci5sZW5ndGg7XG5cbiAgd2hpbGUgKGkgPCBpVG9wKSB7XG4gICAgeSA9IChjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGO1xuICAgIHggPSAnMHgnICsgdGFibGUuc3Vic3RyKHkgKiA5LCA4KTtcbiAgICBjcmMgPSBjcmMgPj4+IDggXiB4O1xuICAgIGkrKztcbiAgfVxuXG4gIGNyYyA9IGNyYyBeIC0xOyAvL2NvbnZlcnQgdG8gdW5zaWduZWQgMzItYml0IGludCBpZiBuZWVkZWRcblxuICBpZiAoY3JjIDwgMCkge1xuICAgIGNyYyArPSA0Mjk0OTY3Mjk2O1xuICB9XG5cbiAgcmV0dXJuIGNyYztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NyYzMyID0gKGNyYzMyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9zdHJpbmdQYWQuanNcbmZ1bmN0aW9uIHN0cmluZ1BhZCh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoID4+IDA7IC8vdHJ1bmNhdGUgaWYgbnVtYmVyIG9yIGNvbnZlcnQgbm9uLW51bWJlciB0byAwO1xuXG4gIHBhZFN0cmluZyA9IFN0cmluZyh0eXBlb2YgcGFkU3RyaW5nICE9PSAndW5kZWZpbmVkJyA/IHBhZFN0cmluZyA6ICcgJyk7XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCAtIHZhbHVlLmxlbmd0aDtcblxuICAgIGlmICh0YXJnZXRMZW5ndGggPiBwYWRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBwYWRTdHJpbmcgKz0gcmVwZWF0U3RyaW5nTnVtVGltZXMocGFkU3RyaW5nLCB0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFkU3RyaW5nLnNsaWNlKDAsIHRhcmdldExlbmd0aCkgKyBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGVhdFN0cmluZ051bVRpbWVzKHN0cmluZywgdGltZXMpIHtcbiAgdmFyIHJlcGVhdGVkU3RyaW5nID0gXCJcIjtcblxuICB3aGlsZSAodGltZXMgPiAwKSB7XG4gICAgcmVwZWF0ZWRTdHJpbmcgKz0gc3RyaW5nO1xuICAgIHRpbWVzLS07XG4gIH1cblxuICByZXR1cm4gcmVwZWF0ZWRTdHJpbmc7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvYmFzZTY0TWFwLmpzXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGJhc2U2NE1hcF9udW0gPSAwO1xudmFyIG1hcCA9IHt9O1xuXG5fdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpLmZvckVhY2goZnVuY3Rpb24gKF9jaGFyKSB7XG4gIHZhciBrZXkgPSBiYXNlNjRNYXBfbnVtLnRvU3RyaW5nKDIpO1xuICBrZXkgPSBzdHJpbmdQYWQoa2V5LCA2LCAnMCcpO1xuICBtYXBba2V5XSA9IF9jaGFyO1xuICBiYXNlNjRNYXBfbnVtKys7XG59KTtcbi8qKlxuICogTWFwIG9mIHNpeC1iaXQgYmluYXJ5IGNvZGVzIHRvIEJhc2U2NCBjaGFyYWN0ZXJzXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXNlNjRNYXAgPSAobWFwKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9yZXZlcnNlVmVyc2lvbi5qc1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBIHNlbVZlciBsaWtlIHN0cmluZywgeC55Lnogb3IgeC55IGlzIGFsbG93ZWRcbiAqICAgICAgICAgICAgICBSZXZlcnNlcyB0aGUgdmVyc2lvbiBwb3NpdGlvbnMsIHgueS56IHR1cm5zIHRvIHoueS54XG4gKiAgICAgICAgICAgICAgUGFkcyBlYWNoIHNlZ21lbnQgd2l0aCAnMCcgc28gdGhleSBoYXZlIGxlbmd0aCBvZiAyXG4gKiAgICAgICAgICAgICAgRXhhbXBsZTogMS4yLjMgLT4gMDMuMDIuMDFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gdGhlIGZvcm0gb2YgenoueXkueHggKFxuICovXG5cbmZ1bmN0aW9uIHJldmVyc2VWZXJzaW9uKHNlbVZlcikge1xuICBpZiAoc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZW1WZXIsIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gc2VnbWVudHMnKTtcbiAgfSAvLyBTcGxpdCBieSAnLicsIHJldmVyc2UsIGNyZWF0ZSBuZXcgYXJyYXkgd2l0aCBwYWRkZWQgdmFsdWVzIGFuZCBjb25jYXQgaXQgdG9nZXRoZXJcblxuXG4gIHJldHVybiBzZW1WZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZ1BhZChzZWdtZW50LCAyLCAnMCcpO1xuICB9KS5qb2luKCcuJyk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZW5jb2RlVmVyc2lvbi5qc1xuXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRW5jb2RlcyBhIHNlbVZlci1saWtlIHZlcnNpb24gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VtVmVyIElucHV0IGNhbiBiZSBlaXRoZXIgeC55Lnogb3IgeC55XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIGJ1aWx0IGZyb20gMyBjaGFyYWN0ZXJzIG9mIHRoZSBiYXNlNjQgdGFibGUgdGhhdCBlbmNvZGUgdGhlIHNlbVZlclxuICovXG5cbmZ1bmN0aW9uIGVuY29kZVZlcnNpb24oc2VtVmVyKSB7XG4gIHZhciBzdHJSZXN1bHQgPSAnJzsgLy8gc3VwcG9ydCB4Lnkgb3IgeC55LnogYnkgdXNpbmcgJ3BhcnRzJyBhcyBhIHZhcmlhYmxlXG5cbiAgdmFyIHBhcnRzID0gc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoO1xuICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gcGFydHMgKiA2OyAvLyB3ZSBwYWQgdG8gZWl0aGVyIDEyIG9yIDE4IGNoYXJhY3RlcnNcbiAgLy8gcmV2ZXJzZSAoYnV0IGRvbid0IG1pcnJvcikgdGhlIHZlcnNpb24uIDEuNS4xNSAtPiAxNS41LjFcbiAgLy8gUGFkIHRvIHR3byBzcGFjZXMsIDE1LjUuMSAtPiAxNS4wNS4wMVxuXG4gIHZhciBwYWRkZWRSZXZlcnNlZFNlbXZlciA9IHJldmVyc2VWZXJzaW9uKHNlbVZlcik7IC8vIHR1cm4gMTUuMDUuMDEgdG8gYSBzdHJpbmcgJzE1MDUwMScgdGhlbiB0byBhIG51bWJlciAxNTA1MDFcblxuICB2YXIgbnVtID0gcGFyc2VJbnQocGFkZGVkUmV2ZXJzZWRTZW12ZXIuc3BsaXQoJy4nKS5qb2luKCcnKSk7IC8vIFJlcHJlc2VudCBhcyBiaW5hcnksIGFkZCBsZWZ0IHBhZGRpbmcgdG8gMTIgb3IgMTggY2hhcmFjdGVycy5cbiAgLy8gMTUwLDUwMSAtPiAxMDAxMDAxMDExMTExMDAxMDFcblxuICB2YXIgcGFkZGVkQmluYXJ5ID0gbnVtLnRvU3RyaW5nKDIpO1xuICBwYWRkZWRCaW5hcnkgPSBzdHJpbmdQYWQocGFkZGVkQmluYXJ5LCBwYWRkZWRTdHJpbmdMZW5ndGgsICcwJyk7IC8vIFN0b3AgaW4gY2FzZSBhbiBpbnZhbGlkIHZlcnNpb24gbnVtYmVyIHdhcyBwcm92aWRlZFxuICAvLyBwYWRkZWRCaW5hcnkgbXVzdCBiZSBidWlsdCBmcm9tIHNlY3Rpb25zIG9mIDYgYml0c1xuXG4gIGlmIChwYWRkZWRCaW5hcnkubGVuZ3RoICUgNiAhPT0gMCkge1xuICAgIHRocm93ICdWZXJzaW9uIG11c3QgYmUgc21hbGxlciB0aGFuIDQzLjIxLjI2KSc7XG4gIH0gLy8gdHVybiBldmVyeSA2IGJpdHMgaW50byBhIGNoYXJhY3RlciB1c2luZyB0aGUgYmFzZTY0TWFwXG5cblxuICBwYWRkZWRCaW5hcnkubWF0Y2goLy57MSw2fS9nKS5mb3JFYWNoKGZ1bmN0aW9uIChiaXRTdHJpbmcpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhiaXRTdHJpbmcpO1xuICAgIHN0clJlc3VsdCArPSBiYXNlNjRNYXBbYml0U3RyaW5nXTtcbiAgfSk7XG4gIHJldHVybiBzdHJSZXN1bHQ7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlLmpzXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIFNESyBzaWduYXR1cmUgYnkgZW5jb2RpbmcgdGhlIFNESyB2ZXJzaW9uIGFuZCB0ZWNoIHZlcnNpb25cbiAqIEBwYXJhbSB7e1xuICogICAgW3RlY2hWZXJzaW9uXTpzdHJpbmcsXG4gKiAgICBbc2RrU2VtdmVyXTogc3RyaW5nLFxuICogICAgW3Nka0NvZGVdOiBzdHJpbmcsXG4gKiAgICBbZmVhdHVyZV06IHN0cmluZ1xuICogfX0gYW5hbHl0aWNzT3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBzZGtBbmFseXRpY3NTaWduYXR1cmVcbiAqL1xuXG5mdW5jdGlvbiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB0cnkge1xuICAgIHZhciB0d29QYXJ0VmVyc2lvbiA9IHJlbW92ZVBhdGNoRnJvbVNlbXZlcihhbmFseXRpY3NPcHRpb25zLnRlY2hWZXJzaW9uKTtcbiAgICB2YXIgZW5jb2RlZFNES1ZlcnNpb24gPSBlbmNvZGVWZXJzaW9uKGFuYWx5dGljc09wdGlvbnMuc2RrU2VtdmVyKTtcbiAgICB2YXIgZW5jb2RlZFRlY2hWZXJzaW9uID0gZW5jb2RlVmVyc2lvbih0d29QYXJ0VmVyc2lvbik7XG4gICAgdmFyIGZlYXR1cmVDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlO1xuICAgIHZhciBTREtDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5zZGtDb2RlO1xuICAgIHZhciBhbGdvVmVyc2lvbiA9ICdBJzsgLy8gVGhlIGFsZ28gdmVyc2lvbiBpcyBkZXRlcm1pbmVkIGhlcmUsIGl0IHNob3VsZCBub3QgYmUgYW4gYXJndW1lbnRcblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChhbGdvVmVyc2lvbikuY29uY2F0KFNES0NvZGUpLmNvbmNhdChlbmNvZGVkU0RLVmVyc2lvbikuY29uY2F0KGVuY29kZWRUZWNoVmVyc2lvbikuY29uY2F0KGZlYXR1cmVDb2RlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVpdGhlciBTREsgb3IgTm9kZSB2ZXJzaW9ucyB3ZXJlIHVucGFyc2FibGVcbiAgICByZXR1cm4gJ0UnO1xuICB9XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHBhdGNoIHZlcnNpb24gZnJvbSB0aGUgc2VtdmVyIGlmIGl0IGV4aXN0c1xuICogICAgICAgICAgICAgIFR1cm5zIHgueS56IE9SIHgueSBpbnRvIHgueVxuICogQHBhcmFtIHsneC55LnonIHx8ICd4LnknIHx8IHN0cmluZ30gc2VtVmVyU3RyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlUGF0Y2hGcm9tU2VtdmVyKHNlbVZlclN0cikge1xuICB2YXIgcGFydHMgPSBzZW1WZXJTdHIuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcnRzWzBdLCBcIi5cIikuY29uY2F0KHBhcnRzWzFdKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9nZXRBbmFseXRpY3NPcHRpb25zLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBhbmFseXRpY3NPcHRpb25zIGZyb20gb3B0aW9ucy0gc2hvdWxkIGluY2x1ZGUgc2RrU2VtdmVyLCB0ZWNoVmVyc2lvbiwgc2RrQ29kZSwgYW5kIGZlYXR1cmVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7e3Nka1NlbXZlcjogKHN0cmluZyksIHNka0NvZGUsIGZlYXR1cmU6IHN0cmluZywgdGVjaFZlcnNpb246IChzdHJpbmcpfSB8fCB7fX1cbiAqL1xuZnVuY3Rpb24gZ2V0QW5hbHl0aWNzT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0ge1xuICAgIHNka1NlbXZlcjogb3B0aW9ucy5zZGtTZW12ZXIsXG4gICAgdGVjaFZlcnNpb246IG9wdGlvbnMudGVjaFZlcnNpb24sXG4gICAgc2RrQ29kZTogb3B0aW9ucy5zZGtDb2RlLFxuICAgIGZlYXR1cmU6ICcwJ1xuICB9O1xuXG4gIGlmIChvcHRpb25zLnVybEFuYWx5dGljcykge1xuICAgIGlmIChvcHRpb25zLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdEJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdDJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQSc7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdCJztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5hbHl0aWNzT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9hc3NpZ25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Fzc2lnblwiLFwiYW1kXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJyb290XCI6W1wiX1wiLFwiYXNzaWduXCJdfVxudmFyIGFzc2lnbl9yb290X2Fzc2lnbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXNzaWduX3Jvb3RfYXNzaWduXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiYW1kXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJyb290XCI6W1wiX1wiLFwiY2xvbmVEZWVwXCJdfVxudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcbnZhciBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJhbWRcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJyb290XCI6W1wiX1wiLFwiY29tcGFjdFwiXX1cbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2NvbXBhY3RcIik7XG52YXIgY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tcGFjdF9yb290X2NvbXBhY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImFtZFwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcInJvb3RcIjpbXCJfXCIsXCJkaWZmZXJlbmNlXCJdfVxudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKTtcbnZhciBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImFtZFwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwicm9vdFwiOltcIl9cIixcImZ1bmN0aW9uc1wiXX1cbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9mdW5jdGlvbnNcIik7XG52YXIgZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJhbWRcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwicm9vdFwiOltcIl9cIixcImlkZW50aXR5XCJdfVxudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pZGVudGl0eVwiKTtcbnZhciBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwiYW1kXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcInJvb3RcIjpbXCJfXCIsXCJpbmNsdWRlc1wiXX1cbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG52YXIgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbmNsdWRlc19yb290X2luY2x1ZGVzXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJhbWRcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJyb290XCI6W1wiX1wiLFwiaXNBcnJheVwiXX1cbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzQXJyYXlcIik7XG52YXIgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNBcnJheV9yb290X2lzQXJyYXlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImFtZFwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcInJvb3RcIjpbXCJfXCIsXCJpc1BsYWluT2JqZWN0XCJdfVxudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKTtcbnZhciBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJhbWRcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwicm9vdFwiOltcIl9cIixcImlzU3RyaW5nXCJdfVxudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1N0cmluZ1wiKTtcbnZhciBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL21lcmdlXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9tZXJnZVwiLFwiYW1kXCI6XCJsb2Rhc2gvbWVyZ2VcIixcInJvb3RcIjpbXCJfXCIsXCJtZXJnZVwiXX1cbnZhciBtZXJnZV9yb290X21lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvbWVyZ2VcIik7XG52YXIgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZXJnZV9yb290X21lcmdlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJyb290XCI6W1wiX1wiLFwiaXNFbGVtZW50XCJdfVxudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRWxlbWVudFwiKTtcbnZhciBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJhbWRcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJyb290XCI6W1wiX1wiLFwiaXNGdW5jdGlvblwiXX1cbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRnVuY3Rpb25cIik7XG52YXIgaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL3RyaW1cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL3RyaW1cIixcImFtZFwiOlwibG9kYXNoL3RyaW1cIixcInJvb3RcIjpbXCJfXCIsXCJ0cmltXCJdfVxudmFyIHRyaW1fcm9vdF90cmltXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvdHJpbVwiKTtcbnZhciB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0cmltX3Jvb3RfdHJpbV8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xhenlMb2FkLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgZm9yIGxhenkgbG9hZGluZyBtZWRpYVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBkZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQoKSB7XG4gIC8vIENoZWNrIHRoYXQgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uIHdpbmRvd1xuICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59XG4vKipcbiAqIENoZWNrIGlmIG5hdGl2ZSBsYXp5IGxvYWRpbmcgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmICdsb2FkaW5nJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIGZvciBIVE1MSW1hZ2VFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxJbWFnZUVsZW1lbnQpKSA9PT0gXCJvYmplY3RcIiAmJiBIVE1MSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5sb2FkaW5nO1xufVxuLyoqXG4gKiBDYWxscyBvbkludGVyc2VjdCgpIHdoZW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBvciB3aGVuXG4gKiBubyBuYXRpdmUgbGF6eSBsb2FkaW5nIG9yIHdoZW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXNuJ3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIHRoZSBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uSW50ZXJzZWN0IC0gY2FsbGVkIHdoZW4gdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW4gdmlld1xuICovXG5cbmZ1bmN0aW9uIGRldGVjdEludGVyc2VjdGlvbihlbCwgb25JbnRlcnNlY3QpIHtcbiAgdHJ5IHtcbiAgICBpZiAoaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHx8ICFpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIC8vIFJldHVybiBpZiB0aGVyZSdzIG5vIG5lZWQgb3IgcG9zc2liaWxpdHkgdG8gZGV0ZWN0IGludGVyc2VjdGlvblxuICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERldGVjdCBpbnRlcnNlY3Rpb24gd2l0aCBnaXZlbiBlbGVtZW50IHVzaW5nIEludGVyc2VjdGlvbk9ic2VydmVyXG5cblxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBvbkludGVyc2VjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICB0aHJlc2hvbGQ6IFswLCAwLjAxXVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb25JbnRlcnNlY3QoKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uc3RhbnRzLmpzXG52YXIgVkVSU0lPTiA9IFwiMi41LjBcIjtcbnZhciBDRl9TSEFSRURfQ0ROID0gXCJkM2pwbDkxcHhldmJraC5jbG91ZGZyb250Lm5ldFwiO1xudmFyIE9MRF9BS0FNQUlfU0hBUkVEX0NETiA9IFwiY2xvdWRpbmFyeS1hLmFrYW1haWhkLm5ldFwiO1xudmFyIEFLQU1BSV9TSEFSRURfQ0ROID0gXCJyZXMuY2xvdWRpbmFyeS5jb21cIjtcbnZhciBTSEFSRURfQ0ROID0gQUtBTUFJX1NIQVJFRF9DRE47XG52YXIgREVGQVVMVF9USU1FT1VUX01TID0gMTAwMDA7XG52YXIgREVGQVVMVF9QT1NURVJfT1BUSU9OUyA9IHtcbiAgZm9ybWF0OiAnanBnJyxcbiAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xufTtcbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyA9IFsnd2VibScsICdtcDQnLCAnb2d2J107XG52YXIgU0VPX1RZUEVTID0ge1xuICBcImltYWdlL3VwbG9hZFwiOiBcImltYWdlc1wiLFxuICBcImltYWdlL3ByaXZhdGVcIjogXCJwcml2YXRlX2ltYWdlc1wiLFxuICBcImltYWdlL2F1dGhlbnRpY2F0ZWRcIjogXCJhdXRoZW50aWNhdGVkX2ltYWdlc1wiLFxuICBcInJhdy91cGxvYWRcIjogXCJmaWxlc1wiLFxuICBcInZpZGVvL3VwbG9hZFwiOiBcInZpZGVvc1wiXG59O1xuLyoqXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfSU1BR0VfUEFSQU1TXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgaW1hZ2UgcGFyYW1ldGVycy5cbipcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xuXG52YXIgREVGQVVMVF9JTUFHRV9QQVJBTVMgPSB7XG4gIHJlc291cmNlX3R5cGU6IFwiaW1hZ2VcIixcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcbi8qKlxuKiBEZWZhdWx0cyB2YWx1ZXMgZm9yIHZpZGVvIHBhcmFtZXRlcnMuXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fUEFSQU1TXG4qIChQcmV2aW91c2x5IGRlZmluZWQgdXNpbmcgb3B0aW9uX2NvbnN1bWUoKSApXG4gKi9cblxudmFyIERFRkFVTFRfVklERU9fUEFSQU1TID0ge1xuICBmYWxsYmFja19jb250ZW50OiAnJyxcbiAgcmVzb3VyY2VfdHlwZTogXCJ2aWRlb1wiLFxuICBzb3VyY2VfdHJhbnNmb3JtYXRpb246IHt9LFxuICBzb3VyY2VfdHlwZXM6IERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTLFxuICB0cmFuc2Zvcm1hdGlvbjogW10sXG4gIHR5cGU6ICd1cGxvYWQnXG59O1xuLyoqXG4gKiBSZWNvbW1lbmRlZCBzb3VyY2VzIGZvciB2aWRlbyB0YWdcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fU09VUkNFU1xuICovXG5cbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRVMgPSBbe1xuICB0eXBlOiBcIm1wNFwiLFxuICBjb2RlY3M6IFwiaGV2MVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJoMjY1XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgY29kZWNzOiBcInZwOVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJ2cDlcIlxuICB9XG59LCB7XG4gIHR5cGU6IFwibXA0XCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcImF1dG9cIlxuICB9XG59LCB7XG4gIHR5cGU6IFwid2VibVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufV07XG52YXIgREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVMgPSB7XG4gIHNlZVRocnU6ICdodHRwczovL3VucGtnLmNvbS9zZWV0aHJ1QDQvZGlzdC9zZWVUaHJ1Lm1pbi5qcydcbn07XG4vKipcbiAqIFByZWRlZmluZWQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5QTEFDRUhPTERFUl9JTUFHRV9NT0RFU1xuICovXG5cbnZhciBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUyA9IHtcbiAgJ2JsdXInOiBbe1xuICAgIGVmZmVjdDogJ2JsdXI6MjAwMCcsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gRGVmYXVsdFxuICAncGl4ZWxhdGUnOiBbe1xuICAgIGVmZmVjdDogJ3BpeGVsYXRlJyxcbiAgICBxdWFsaXR5OiAxLFxuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nXG4gIH1dLFxuICAvLyBHZW5lcmF0ZXMgYSBwaXhlbCBzaXplIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvci1waXhlbCc6IFt7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBncmF2aXR5OiAnbm9ydGhfZWFzdCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGFuIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvcic6IFt7XG4gICAgdmFyaWFibGVzOiBbWyckY3VycldpZHRoJywgJ3cnXSwgWyckY3VyckhlaWdodCcsICdoJ11dXG4gIH0sIHtcbiAgICB3aWR0aDogJ2l3X2Rpdl8yJyxcbiAgICBhc3BlY3RfcmF0aW86IDEsXG4gICAgY3JvcDogJ3BhZCcsXG4gICAgYmFja2dyb3VuZDogJ2F1dG8nXG4gIH0sIHtcbiAgICBjcm9wOiAnY3JvcCcsXG4gICAgd2lkdGg6IDEwLFxuICAgIGhlaWdodDogMTAsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICB3aWR0aDogJyRjdXJyV2lkdGgnLFxuICAgIGhlaWdodDogJyRjdXJySGVpZ2h0JyxcbiAgICBjcm9wOiAnZmlsbCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgJ3ZlY3Rvcml6ZSc6IFt7XG4gICAgZWZmZWN0OiAndmVjdG9yaXplOjM6MC4xJyxcbiAgICBmZXRjaF9mb3JtYXQ6ICdzdmcnXG4gIH1dXG59O1xuLyoqXG4gKiBQcmVkZWZpbmVkIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5BQ0NFU1NJQklMSVRZX01PREVTXG4gKi9cblxudmFyIEFDQ0VTU0lCSUxJVFlfTU9ERVMgPSB7XG4gIGRhcmttb2RlOiAndGludDo3NTpibGFjaycsXG4gIGJyaWdodG1vZGU6ICd0aW50OjUwOndoaXRlJyxcbiAgbW9ub2Nocm9tZTogJ2dyYXlzY2FsZScsXG4gIGNvbG9yYmxpbmQ6ICdhc3Npc3RfY29sb3JibGluZCdcbn07XG4vKipcbiAqIEEgbGlzdCBvZiBrZXlzIHVzZWQgYnkgdGhlIHVybCgpIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVVJMX0tFWVMgPSBbJ2FjY2Vzc2liaWxpdHknLCAnYXBpX3NlY3JldCcsICdhdXRoX3Rva2VuJywgJ2Nkbl9zdWJkb21haW4nLCAnY2xvdWRfbmFtZScsICdjbmFtZScsICdmb3JtYXQnLCAncGxhY2Vob2xkZXInLCAncHJpdmF0ZV9jZG4nLCAncmVzb3VyY2VfdHlwZScsICdzZWN1cmUnLCAnc2VjdXJlX2Nkbl9zdWJkb21haW4nLCAnc2VjdXJlX2Rpc3RyaWJ1dGlvbicsICdzaG9ydGVuJywgJ3NpZ25fdXJsJywgJ3NpZ25hdHVyZScsICdzc2xfZGV0ZWN0ZWQnLCAndHlwZScsICd1cmxfc3VmZml4JywgJ3VzZV9yb290X3BhdGgnLCAndmVyc2lvbiddO1xuLyoqXG4gKiBUaGUgcmVzb3VyY2Ugc3RvcmFnZSB0eXBlXG4gKiBAdHlwZWRlZiB0eXBlXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndXBsb2FkJyBBIHJlc291cmNlIHVwbG9hZGVkIGRpcmVjdGx5IHRvIENsb3VkaW5hcnlcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2ZldGNoJyBBIHJlc291cmNlIGZldGNoZWQgYnkgQ2xvdWRpbmFyeSBmcm9tIGEgM3JkIHBhcnR5IHN0b3JhZ2VcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ByaXZhdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdhdXRoZW50aWNhdGVkJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnc3ByaXRlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmFjZWJvb2snXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd0d2l0dGVyJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAneW91dHViZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ZpbWVvJ1xuICpcbiAqL1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSB0eXBlXG4gKiBAdHlwZWRlZiByZXNvdXJjZVR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ2ltYWdlJyBBbiBpbWFnZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ3ZpZGVvJyBBIHZpZGVvIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAncmF3JyAgIEEgcmF3IGZpbGVcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9iYXNldXRpbC5qc1xuZnVuY3Rpb24gYmFzZXV0aWxfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBiYXNldXRpbF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBiYXNldXRpbF90eXBlb2Yob2JqKTsgfVxuXG4vKlxuICogSW5jbHVkZXMgY29tbW9uIHV0aWxpdHkgbWV0aG9kcyBhbmQgc2hpbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgdmFyIHNyY0tleXMgPSBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShrZXlzLCBrZXkpO1xuICB9KTtcbiAgdmFyIGZpbHRlcmVkID0ge307XG4gIHNyY0tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkW2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYWxsIGl0ZW1zIGluIGxpc3QgYXJlIHN0cmluZ3NcbiAqIEBmdW5jdGlvbiBVdGlsLmFsbFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGFuIGFycmF5IG9mIGl0ZW1zXG4gKi9cblxudmFyIGJhc2V1dGlsX2FsbFN0cmluZ3MgPSBmdW5jdGlvbiBhbGxTdHJpbmdzKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubGVuZ3RoICYmIGxpc3QuZXZlcnkoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmEpO1xufTtcbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIGdpdmVuIGl0ZW0uXG4qIEBmdW5jdGlvbiBVdGlsLndpdGhvdXRcbiogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBvcmlnaW5hbCBhcnJheVxuKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBleGNsdWRlIGZyb20gdGhlIG5ldyBhcnJheVxuKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgbWFkZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkncyBpdGVtcyBleGNlcHQgZm9yIGBpdGVtYFxuICovXG5cbnZhciB3aXRob3V0ID0gZnVuY3Rpb24gd2l0aG91dChhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IGl0ZW07XG4gIH0pO1xufTtcbi8qKlxuKiBSZXR1cm4gdHJ1ZSBpcyB2YWx1ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlci5cbiogQGZ1bmN0aW9uIFV0aWwuaXNOdW1iZXJMaWtlXG4qIEBwYXJhbSB7Kn0gdmFsdWVcbiogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXJcbiogQGV4YW1wbGVcbiogICAgVXRpbC5pc051bWJlcigwKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCIxLjNcIikgLy8gdHJ1ZVxuKiAgICBVdGlsLmlzTnVtYmVyKFwiXCIpIC8vIGZhbHNlXG4qICAgIFV0aWwuaXNOdW1iZXIodW5kZWZpbmVkKSAvLyBmYWxzZVxuICovXG5cbnZhciBpc051bWJlckxpa2UgPSBmdW5jdGlvbiBpc051bWJlckxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG4vKipcbiAqIEVzY2FwZSBhbGwgY2hhcmFjdGVycyBtYXRjaGluZyB1bnNhZmUgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuc21hcnRFc2NhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBzb3VyY2Ugc3RyaW5nIHRvIGVzY2FwZVxuICogQHBhcmFtIHtSZWdFeHB9IHVuc2FmZSAtIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIGVzY2FwZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqL1xuXG52YXIgc21hcnRFc2NhcGUgPSBmdW5jdGlvbiBzbWFydEVzY2FwZShzdHJpbmcpIHtcbiAgdmFyIHVuc2FmZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogLyhbXmEtekEtWjAtOV8uXFwtXFwvOl0rKS9nO1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodW5zYWZlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBBc3NpZ24gdmFsdWVzIGZyb20gc291cmNlcyBpZiB0aGV5IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgZGVzdGluYXRpb24uXG4gKiBPbmNlIGEgdmFsdWUgaXMgc2V0IGl0IGRvZXMgbm90IGNoYW5nZVxuICogQGZ1bmN0aW9uIFV0aWwuZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIGRlZmF1bHRzIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlIC0gdGhlIHNvdXJjZSBvYmplY3QocykgdG8gYXNzaWduIGRlZmF1bHRzIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gZGVzdGluYXRpb24gYWZ0ZXIgaXQgd2FzIG1vZGlmaWVkXG4gKi9cblxudmFyIGRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMoZGVzdGluYXRpb24pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZXMucmVkdWNlKGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgaWYgKGRlc3Rba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9LCBkZXN0aW5hdGlvbik7XG59O1xuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cblxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xuXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiNpc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZTsgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgdHlwZSA9IGJhc2V1dGlsX3R5cGVvZih2YWx1ZSk7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4vKipcbiogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuKiBAZnVuY3Rpb24gVXRpbC5pc0Z1bmN0aW9uXG4qIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuKiBAZXhhbXBsZVxuKlxuKiBmdW5jdGlvbiBGb28oKXt9O1xuKiBpc0Z1bmN0aW9uKEZvbyk7XG4qIC8vID0+IHRydWVcbipcbiogaXNGdW5jdGlvbigvYWJjLyk7XG4qIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBmdW5jVGFnO1xufTtcbi8qKioqKioqKioqKiBsb2Rhc2ggZnVuY3Rpb25zICovXG5cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cblxudmFyIHJlV29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb3dlciwgdXBwZXI7XG4gIHVwcGVyID0gJ1tBLVpdJztcbiAgbG93ZXIgPSAnW2Etel0rJztcbiAgcmV0dXJuIFJlZ0V4cCh1cHBlciArICcrKD89JyArIHVwcGVyICsgbG93ZXIgKyAnKXwnICsgdXBwZXIgKyAnPycgKyBsb3dlciArICd8JyArIHVwcGVyICsgJyt8WzAtOV0rJywgJ2cnKTtcbn0oKTtcbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBjYW1lbENhc2VcbiogQGZ1bmN0aW9uIFV0aWwuY2FtZWxDYXNlXG4qIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiogQHJldHVybiB7c3RyaW5nfSBpbiBjYW1lbENhc2UgZm9ybWF0XG4gKi9cblxudmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b0xvY2FsZVVwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICB9KTtcbiAgd29yZHNbMF0gPSB3b3Jkc1swXS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICByZXR1cm4gd29yZHMuam9pbignJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyB0byBzbmFrZV9jYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC5zbmFrZUNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gc25ha2VfY2FzZSBmb3JtYXRcbiAqL1xuXG52YXIgc25ha2VDYXNlID0gZnVuY3Rpb24gc25ha2VDYXNlKHNvdXJjZSkge1xuICB2YXIgd29yZHMgPSBzb3VyY2UubWF0Y2gocmVXb3Jkcyk7XG4gIHdvcmRzID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHJldHVybiB3b3Jkcy5qb2luKCdfJyk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIHNvdXJjZSwgd2l0aCB0aGUga2V5cyB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgY29udmVydGVyLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxudmFyIGNvbnZlcnRLZXlzID0gZnVuY3Rpb24gY29udmVydEtleXMoc291cmNlLCBjb252ZXJ0ZXIpIHtcbiAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAga2V5ID0gY29udmVydGVyKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0VtcHR5KGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHNvdXJjZSBvYmplY3Qgd2l0aCBhbGwga2V5cyBpbiBjYW1lbENhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhDYW1lbENhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cblxudmFyIHdpdGhDYW1lbENhc2VLZXlzID0gZnVuY3Rpb24gd2l0aENhbWVsQ2FzZUtleXMoc291cmNlKSB7XG4gIHJldHVybiBjb252ZXJ0S2V5cyhzb3VyY2UsIGNhbWVsQ2FzZSk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gc25ha2VfY2FzZVxuICogQGZ1bmN0aW9uIFV0aWwud2l0aFNuYWtlQ2FzZUtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3RcbiAqL1xuXG52YXIgd2l0aFNuYWtlQ2FzZUtleXMgPSBmdW5jdGlvbiB3aXRoU25ha2VDYXNlS2V5cyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbnZlcnRLZXlzKHNvdXJjZSwgc25ha2VDYXNlKTtcbn07IC8vIEJyb3dzZXJcbi8vIE5vZGUuanNcblxudmFyIGJhc2U2NEVuY29kZSA9IHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJyAmJiBpc0Z1bmN0aW9uKGJ0b2EpID8gYnRvYSA6IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oQnVmZmVyKSA/IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIuZnJvbShTdHJpbmcoaW5wdXQpLCAnYmluYXJ5Jyk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlNjQgZW5jb2RpbmcgZnVuY3Rpb24gZm91bmRcIik7XG59O1xuLyoqXG4qIFJldHVybnMgdGhlIEJhc2U2NC1kZWNvZGVkIHZlcnNpb24gb2YgdXJsLjxicj5cbiogVGhpcyBtZXRob2QgZGVsZWdhdGVzIHRvIGBidG9hYCBpZiBwcmVzZW50LiBPdGhlcndpc2UgaXQgdHJpZXMgYEJ1ZmZlcmAuXG4qIEBmdW5jdGlvbiBVdGlsLmJhc2U2NEVuY29kZVVSTFxuKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIHVybCB0byBlbmNvZGUuIHRoZSB2YWx1ZSBpcyBVUklkZWNvZGVkIGFuZCB0aGVuIHJlLWVuY29kZWQgYmVmb3JlIGNvbnZlcnRpbmcgdG8gYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4qIEByZXR1cm4ge3N0cmluZ30gdGhlIGJhc2U2NCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJMXG4gKi9cblxudmFyIGJhc2U2NEVuY29kZVVSTCA9IGZ1bmN0aW9uIGJhc2U2NEVuY29kZVVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICB1cmwgPSBkZWNvZGVVUkkodXJsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlNjRFbmNvZGUodXJsKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgc291cmNlIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdFVybFBhcmFtcyhvcHRpb25zKSB7XG4gIHJldHVybiBVUkxfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgaWYgKG9wdGlvbnNba2V5XSAhPSBudWxsKSB7XG4gICAgICBvYmpba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59XG4vKipcbiAqIEhhbmRsZSB0aGUgZm9ybWF0IHBhcmFtZXRlciBmb3IgZmV0Y2ggdXJsc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zIHVybCBhbmQgdHJhbnNmb3JtYXRpb24gb3B0aW9ucy4gVGhpcyBhcmd1bWVudCBtYXkgYmUgY2hhbmdlZCBieSB0aGUgZnVuY3Rpb24hXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAob3B0aW9ucy50eXBlID09PSBcImZldGNoXCIpIHtcbiAgICBpZiAob3B0aW9ucy5mZXRjaF9mb3JtYXQgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5mZXRjaF9mb3JtYXQgPSBvcHRpb25Db25zdW1lKG9wdGlvbnMsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEZWxldGVzIGBvcHRpb25fbmFtZWAgZnJvbSBgb3B0aW9uc2AgYW5kIHJldHVybiB0aGUgdmFsdWUgaWYgcHJlc2VudC5cbiAqIElmIGBvcHRpb25zYCBkb2Vzbid0IGNvbnRhaW4gYG9wdGlvbl9uYW1lYCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGEgY29sbGVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbl9uYW1lIHRoZSBuYW1lIChrZXkpIG9mIHRoZSBkZXNpcmVkIHZhbHVlXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSB0aGUgdmFsdWUgdG8gcmV0dXJuIGlzIG9wdGlvbl9uYW1lIGlzIG1pc3NpbmdcbiAqL1xuXG5mdW5jdGlvbiBvcHRpb25Db25zdW1lKG9wdGlvbnMsIG9wdGlvbl9uYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvcHRpb25zW29wdGlvbl9uYW1lXTtcbiAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uX25hbWVdO1xuXG4gIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRfdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5OlxuICogPHVsPlxuICogICA8bGk+dmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+dmFsdWUgaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIG5vIGtleXM8L2xpPlxuICogPC91bD5cbiAqIEBmdW5jdGlvbiBVdGlsLmlzRW1wdHlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgZW1wdHlcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNpemUgPT09IDA7XG4gIH1cblxuICBpZiAoYmFzZXV0aWxfdHlwZW9mKHZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvYnJvd3Nlci5qc1xuLyoqXG4gKiBCYXNlZCBvbiB2aWRlby5qcyBpbXBsZW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2Jsb2IvNDIzOGY1YzFkODg4OTA1NDcxNTNlN2UxZGU3YmQwZDFkOGUwYjIzNi9zcmMvanMvdXRpbHMvYnJvd3Nlci5qc1xuICovXG5cbi8qKlxuKiBSZXRyaWV2ZSBmcm9tIHRoZSBuYXZpZ2F0b3IgdGhlIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qIEByZXR1cm5zIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qL1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEFuZHJvaWRcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEFuZHJvaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEVkZ2VcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEVkZ2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0VkZ2UoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9FZGcvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgY2hyb21lLlxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgQ2hyb21lLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuICFpc0VkZ2UoKSAmJiAoL0Nocm9tZS9pLnRlc3QodXNlckFnZW50KSB8fCAvQ3JpT1MvaS50ZXN0KHVzZXJBZ2VudCkpO1xufVxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBVc2VyIGFnZW50cyBmb3Igb3RoZXIgYnJvd3NlcnMgbWlnaHQgaW5jbHVkZSBcIlNhZmFyaVwiIHNvIHdlIG11c3QgZXhjbHVkZSB0aGVtLlxuICAvLyBGb3IgZXhhbXBsZSAtIHRoaXMgaXMgdGhlIGNocm9tZSB1c2VyIGFnZW50IG9uIHdpbmRvd3MgMTA6XG4gIC8vIE1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85Ni4wLjQ2NjQuMTEwIFNhZmFyaS81MzcuMzZcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL1NhZmFyaS9pLnRlc3QodXNlckFnZW50KSAmJiAhaXNDaHJvbWUoKSAmJiAhaXNBbmRyb2lkKCkgJiYgIWlzRWRnZSgpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9sb2Rhc2guanNcbnZhciBub2RlQ29udGFpbnM7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgYW5kIGxvZGFzaCAvIGpRdWVyeSBzaGltc1xuICovXG5cbi8qKlxuICogR2V0IGRhdGEgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2Qgd2lsbCB1c2UgalF1ZXJ5J3MgYGRhdGEoKWAgbWV0aG9kIGlmIGl0IGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IHRoZSBgZGF0YS1gIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBkYXRhIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYG5hbWVgXG4gKiBAZnVuY3Rpb24gVXRpbC5nZXREYXRhXG4gKi9cblxudmFyIGxvZGFzaF9nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSkpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyKFwiZGF0YS1cIi5jb25jYXQobmFtZSkpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUpO1xuXG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSk7XG4gIH1cbn07XG4vKipcbiAqIFNldCBkYXRhIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBzZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gVXRpbC5zZXREYXRhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGRhdGEgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqXG4gKi9cblxudmFyIGxvZGFzaF9zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUsIHZhbHVlKTtcblxuICAgIGNhc2UgIShpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLmRhdGEpICYmIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpOlxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtZW50KS5kYXRhKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbi8qKlxuICogR2V0IGF0dHJpYnV0ZSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gVXRpbC5nZXRBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqXG4gKi9cblxudmFyIGxvZGFzaF9nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYXR0cihuYW1lKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cihuYW1lKTtcbiAgfVxufTtcbi8qKlxuICogU2V0IGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqL1xuXG52YXIgbG9kYXNoX3NldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbi8qKlxuICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwucmVtb3ZlQXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG5cbnZhciBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdm9pZCAwKTtcbiAgfVxufTtcbi8qKlxuICogU2V0IGEgZ3JvdXAgb2YgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGVzIGZvclxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhIGhhc2ggb2YgYXR0cmlidXRlIG5hbWVzIGFuZCB2YWx1ZXNcbiAqL1xuXG52YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICB2YXIgbmFtZSwgcmVzdWx0cywgdmFsdWU7XG4gIHJlc3VsdHMgPSBbXTtcblxuICBmb3IgKG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3JlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgZWxlbWVudCBoYXMgYSBjc3MgY2xhc3NcbiAqIEBmdW5jdGlvbiBVdGlsLmhhc0NsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZVxuIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3NcbiAqL1xuXG52YXIgbG9kYXNoX2hhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpO1xuICB9XG59O1xuLyoqXG4gKiBBZGQgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAqIEBmdW5jdGlvbiBVdGlsLmFkZENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiAqL1xuXG52YXIgbG9kYXNoX2FkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoIWVsZW1lbnQuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcYlwiLmNvbmNhdChuYW1lLCBcIlxcXFxiXCIpKSkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUgPSB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0KCkoXCJcIi5jb25jYXQoZWxlbWVudC5jbGFzc05hbWUsIFwiIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG59OyAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgdGFrZW4gZnJvbSBqUXVlcnlcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIGdldFN0eWxlcyhlbGVtKSB7XG4gIC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG4gIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcbiAgaWYgKGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIpIHtcbiAgICByZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG59O1xudmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcblxubm9kZUNvbnRhaW5zID0gZnVuY3Rpb24gbm9kZUNvbnRhaW5zKGEsIGIpIHtcbiAgdmFyIGFkb3duLCBidXA7XG4gIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYTtcbiAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiBhZG93bi5jb250YWlucyhidXApKTtcbn07IC8vIFRydW5jYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lKVxuXG5cbnZhciBkb21TdHlsZSA9IGZ1bmN0aW9uIGRvbVN0eWxlKGVsZW0sIG5hbWUpIHtcbiAgaWYgKCEoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSkge1xuICAgIHJldHVybiBlbGVtLnN0eWxlW25hbWVdO1xuICB9XG59O1xudmFyIGN1ckNTUyA9IGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xuICB2YXIgbWF4V2lkdGgsIG1pbldpZHRoLCByZXQsIHJtYXJnaW4sIHN0eWxlLCB3aWR0aDtcbiAgcm1hcmdpbiA9IC9ebWFyZ2luLztcbiAgd2lkdGggPSB2b2lkIDA7XG4gIG1pbldpZHRoID0gdm9pZCAwO1xuICBtYXhXaWR0aCA9IHZvaWQgMDtcbiAgcmV0ID0gdm9pZCAwO1xuICBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuXG4gIGlmIChjb21wdXRlZCkge1xuICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG4gICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFtuYW1lXTtcbiAgfVxuXG4gIGlmIChjb21wdXRlZCkge1xuICAgIGlmIChyZXQgPT09IFwiXCIgJiYgIW5vZGVDb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pKSB7XG4gICAgICByZXQgPSBkb21TdHlsZShlbGVtLCBuYW1lKTtcbiAgICB9IC8vIFN1cHBvcnQ6IGlPUyA8IDZcbiAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgLy8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuICAgIC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXG5cbiAgICBpZiAocm51bW5vbnB4LnRlc3QocmV0KSAmJiBybWFyZ2luLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDsgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXG4gICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG4gICAgICByZXQgPSBjb21wdXRlZC53aWR0aDsgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXG4gICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgfVxuICB9IC8vIFN1cHBvcnQ6IElFXG4gIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cblxuICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmV0ICsgXCJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIGNzc1ZhbHVlID0gZnVuY3Rpb24gY3NzVmFsdWUoZWxlbSwgbmFtZSwgY29udmVydCwgc3R5bGVzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuXG4gIGlmIChjb252ZXJ0KSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIGF1Z21lbnRXaWR0aE9ySGVpZ2h0ID0gZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgc2lkZSwgc2lkZXMsIHZhbDsgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG4gIC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblxuICBpZiAoZXh0cmEgPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICBzaWRlcyA9IG5hbWUgPT09IFwid2lkdGhcIiA/IFtcIlJpZ2h0XCIsIFwiTGVmdFwiXSA6IFtcIlRvcFwiLCBcIkJvdHRvbVwiXTtcbiAgICB2YWwgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc2lkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZGUgPSBzaWRlc1tpXTtcblxuICAgICAgaWYgKGV4dHJhID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIGV4dHJhICsgc2lkZSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQm9yZGVyQm94KSB7XG4gICAgICAgIGlmIChleHRyYSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJwYWRkaW5nXCIuY29uY2F0KHNpZGUpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcblxuICAgICAgICBpZiAoZXh0cmEgIT09IFwicGFkZGluZ1wiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuICAgICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBcImJvcmRlclwiLmNvbmNhdChzaWRlLCBcIldpZHRoXCIpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcbnZhciBwbnVtID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKTtcbnZhciBnZXRXaWR0aE9ySGVpZ2h0ID0gZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSkge1xuICB2YXIgaXNCb3JkZXJCb3gsIHN0eWxlcywgdmFsLCB2YWx1ZUlzQm9yZGVyQm94OyAvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXG4gIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcbiAgaXNCb3JkZXJCb3ggPSBjc3NWYWx1ZShlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCI7IC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cbiAgaWYgKHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG5cbiAgICBpZiAodmFsIDwgMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgdmFsID0gZWxlbS5zdHlsZVtuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSAvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICAvLyAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggYW5kIChzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgb3IgdmFsIGlzIGVsZW0uc3R5bGVbbmFtZV0pXG5cblxuICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiB2YWwgPT09IGVsZW0uc3R5bGVbbmFtZV07IC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuICB9IC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cblxuICByZXR1cm4gdmFsICsgYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgdmFsdWVJc0JvcmRlckJveCwgc3R5bGVzKTtcbn07XG52YXIgbG9kYXNoX3dpZHRoID0gZnVuY3Rpb24gd2lkdGgoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtZW50LCBcIndpZHRoXCIsIFwiY29udGVudFwiKTtcbn07XG4vKipcbiAqIEBjbGFzcyBVdGlsXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBhIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuaXNTdHJpbmdcbiAqIEBwYXJhbSBpdGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPml0ZW0gaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBhcnJheSBvciBzdHJpbmcgb2YgbGVuZ3RoIDA8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gaXRlbVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXRlbSBpcyBlbXB0eVxuICovXG5cbi8qKlxuICogQXNzaWduIHNvdXJjZSBwcm9wZXJ0aWVzIHRvIGRlc3RpbmF0aW9uLlxuICogSWYgdGhlIHByb3BlcnR5IGlzIGFuIG9iamVjdCBpdCBpcyBhc3NpZ25lZCBhcyBhIHdob2xlLCBvdmVycmlkaW5nIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAZnVuY3Rpb24gVXRpbC5hc3NpZ25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIHRvXG4gKi9cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBhc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb25cbiAqIEBmdW5jdGlvbiBVdGlsLm1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCBpbmNsdWRpbmcgYWxsIGludGVybmFsIG9iamVjdHMuXG4gKiBAZnVuY3Rpb24gVXRpbC5jbG9uZURlZXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgZGVlcCBjb3B5IG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgZnJvbSB0aGUgcGFyYW1ldGVyIHdpdGggXCJmYWxzZXlcIiB2YWx1ZXMgcmVtb3ZlZFxuICogQGZ1bmN0aW9uIFV0aWwuY29tcGFjdFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gcmVtb3ZlIHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgd2l0aG91dCBmYWxzZXkgdmFsdWVzXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5jb250YWluc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGluIHRoZSBhcnJheVxuICovXG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgYXJyYXlcbiAqIEBmdW5jdGlvbiBVdGlsLmRpZmZlcmVuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIHRoZSBhcnJheSB0byBzZWxlY3QgZnJvbVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gdmFsdWVzIHRvIGZpbHRlciBmcm9tIGFyclxuICogQHJldHVybiB7QXJyYXl9IHRoZSBmaWx0ZXJlZCB2YWx1ZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgZnVuY3Rpb24gbmFtZXMgaW4gb2JqXG4gKiBAZnVuY3Rpb24gVXRpbC5mdW5jdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgb2YgZnVuY3Rpb25zIG9mIG9iamVjdFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoaXMgZnVuY3Rpb25zIGlzIHVzZWQgYXMgYSBkZWZhdWx0IHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvbiBVdGlsLmlkZW50aXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfSB0aGUgcHJvdmlkZWQgdmFsdWVcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlcyBmcm9tIHRleHRcbiAqIEBmdW5jdGlvbiBVdGlsLnRyaW1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBgdGV4dGAgd2l0aG91dCBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlc1xuICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9leHByZXNzaW9uLmpzXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblN0ciAtIEFuIGV4cHJlc3Npb24gaW4gc3RyaW5nIGZvcm1hdC5cbiAqIEBjbGFzcyBFeHByZXNzaW9uXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqL1xudmFyIEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHByZXNzaW9uKGV4cHJlc3Npb25TdHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwcmVzc2lvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlubmVyIEV4cHJlc3Npb24tZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG5cbiAgICBpZiAoZXhwcmVzc2lvblN0ciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goRXhwcmVzc2lvbi5ub3JtYWxpemUoZXhwcmVzc2lvblN0cikpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3IgbWV0aG9kXG4gICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLm5ld1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHByZXNzaW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb24ubm9ybWFsaXplKHRoaXMuZXhwcmVzc2lvbnMuam9pbihcIl9cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIFRyYW5zZm9ybWF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybWF0aW9ufSB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3ByZWRpY2F0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZGljYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRpY2F0ZShuYW1lLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIGlmIChFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRvciA9IEV4cHJlc3Npb24uT1BFUkFUT1JTW29wZXJhdG9yXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQob3BlcmF0b3IsIFwiX1wiKS5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNhbmRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmQoKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJhbmRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yKCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwib3JcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uY2x1ZGUgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3RoZW5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn0gdGhlIHRyYW5zZm9ybWF0aW9uIHRoaXMgZXhwcmVzc2lvbiBpcyBkZWZpbmVkIGZvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidGhlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KClbXCJpZlwiXSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJoXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3dpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcIndcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYXNwZWN0UmF0aW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiYXJcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcGFnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJwY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNmYWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImZjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF92YWx1ZSkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKF92YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KGV4cHJlc3Npb25TdHIpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhleHByZXNzaW9uU3RyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgc3RyaW5nIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNub3JtYWxpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBhIGV4cHJlc3Npb24sIGUuZy4gXCJ3IGd0IDEwMFwiLCBcIndpZHRoX2d0XzEwMFwiLCBcIndpZHRoID4gMTAwXCJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBub3JtYWxpemVkIGZvcm0gb2YgdGhlIHZhbHVlIGV4cHJlc3Npb24sIGUuZy4gXCJ3X2d0XzEwMFwiXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKGV4cHJlc3Npb24pIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG5cbiAgICAgIGV4cHJlc3Npb24gPSBTdHJpbmcoZXhwcmVzc2lvbik7XG4gICAgICB2YXIgb3BlcmF0b3JzID0gXCJcXFxcfFxcXFx8fD49fDw9fCYmfCE9fD58PXw8fC98LXxcXFxcK3xcXFxcKnxcXFxcXlwiOyAvLyBvcGVyYXRvcnNcblxuICAgICAgdmFyIG9wZXJhdG9yc1BhdHRlcm4gPSBcIigoXCIgKyBvcGVyYXRvcnMgKyBcIikoPz1bIF9dKSlcIjtcbiAgICAgIHZhciBvcGVyYXRvcnNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKG9wZXJhdG9yc1BhdHRlcm4sIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2Uob3BlcmF0b3JzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uT1BFUkFUT1JTW21hdGNoXTtcbiAgICAgIH0pOyAvLyBwcmVkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgLy8gVGhlIDoke3Z9IHBhcnQgaXMgdG8gcHJldmVudCBub3JtYWxpemF0aW9uIG9mIHZhcnMgd2l0aCBhIHByZWNlZGluZyBjb2xvbiAoc3VjaCBhcyA6ZHVyYXRpb24pLFxuICAgICAgLy8gSXQgd29uJ3QgYmUgZm91bmQgaW4gUFJFREVGSU5FRF9WQVJTIGFuZCBzbyB3b24ndCBiZSBub3JtYWxpemVkLlxuICAgICAgLy8gSXQgaXMgZG9uZSBsaWtlIHRoaXMgYmVjYXVzZSBpZTExIGRvZXMgbm90IHN1cHBvcnQgcmVnZXggbG9va2JlaGluZFxuXG4gICAgICB2YXIgcHJlZGVmaW5lZFZhcnNQYXR0ZXJuID0gXCIoXCIgKyBPYmplY3Qua2V5cyhFeHByZXNzaW9uLlBSRURFRklORURfVkFSUykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBcIjpcIi5jb25jYXQodiwgXCJ8XCIpLmNvbmNhdCh2KTtcbiAgICAgIH0pLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gICAgICB2YXIgdXNlclZhcmlhYmxlUGF0dGVybiA9ICcoXFxcXCRfKlteXyBdKyknO1xuICAgICAgdmFyIHZhcmlhYmxlc1JlcGxhY2VSRSA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQodXNlclZhcmlhYmxlUGF0dGVybiwgXCJ8XCIpLmNvbmNhdChwcmVkZWZpbmVkVmFyc1BhdHRlcm4pLCBcImdcIik7XG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKHZhcmlhYmxlc1JlcGxhY2VSRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBFeHByZXNzaW9uLlBSRURFRklORURfVkFSU1ttYXRjaF0gfHwgbWF0Y2g7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLnJlcGxhY2UoL1sgX10rL2csICdfJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSkudmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcIndpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi53aWR0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJ3aWR0aFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJoZWlnaHRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImhlaWdodFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsV2lkdGhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxXaWR0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxXaWR0aCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxXaWR0aFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsSGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsSGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsSGVpZ2h0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5hc3BlY3RSYXRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJhc3BlY3RSYXRpb1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsQXNwZWN0UmF0aW9cIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxBc3BlY3RSYXRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbEFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxBc3BlY3RSYXRpbygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxBc3BlY3RSYXRpb1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlQ291bnRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VDb3VudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VDb3VudFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiZmFjZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5mYWNlQ291bnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJmYWNlQ291bnRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiY3VycmVudFBhZ2VcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmN1cnJlbnRQYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50UGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJyZW50UGFnZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImN1cnJlbnRQYWdlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInRhZ3NcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnRhZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFncygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInRhZ3NcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZVhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VYXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlWCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VYXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VZXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZVkoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlWVwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuXG5FeHByZXNzaW9uLk9QRVJBVE9SUyA9IHtcbiAgXCI9XCI6ICdlcScsXG4gIFwiIT1cIjogJ25lJyxcbiAgXCI8XCI6ICdsdCcsXG4gIFwiPlwiOiAnZ3QnLFxuICBcIjw9XCI6ICdsdGUnLFxuICBcIj49XCI6ICdndGUnLFxuICBcIiYmXCI6ICdhbmQnLFxuICBcInx8XCI6ICdvcicsXG4gIFwiKlwiOiBcIm11bFwiLFxuICBcIi9cIjogXCJkaXZcIixcbiAgXCIrXCI6IFwiYWRkXCIsXG4gIFwiLVwiOiBcInN1YlwiLFxuICBcIl5cIjogXCJwb3dcIlxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMgPSB7XG4gIFwiYXNwZWN0X3JhdGlvXCI6IFwiYXJcIixcbiAgXCJhc3BlY3RSYXRpb1wiOiBcImFyXCIsXG4gIFwiY3VycmVudF9wYWdlXCI6IFwiY3BcIixcbiAgXCJjdXJyZW50UGFnZVwiOiBcImNwXCIsXG4gIFwiZHVyYXRpb25cIjogXCJkdVwiLFxuICBcImZhY2VfY291bnRcIjogXCJmY1wiLFxuICBcImZhY2VDb3VudFwiOiBcImZjXCIsXG4gIFwiaGVpZ2h0XCI6IFwiaFwiLFxuICBcImluaXRpYWxfYXNwZWN0X3JhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbF9kdXJhdGlvblwiOiBcImlkdVwiLFxuICBcImluaXRpYWxfaGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsX3dpZHRoXCI6IFwiaXdcIixcbiAgXCJpbml0aWFsQXNwZWN0UmF0aW9cIjogXCJpYXJcIixcbiAgXCJpbml0aWFsRHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsSGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsV2lkdGhcIjogXCJpd1wiLFxuICBcInBhZ2VfY291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VfeFwiOiBcInB4XCIsXG4gIFwicGFnZV95XCI6IFwicHlcIixcbiAgXCJwYWdlQ291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VYXCI6IFwicHhcIixcbiAgXCJwYWdlWVwiOiBcInB5XCIsXG4gIFwidGFnc1wiOiBcInRhZ3NcIixcbiAgXCJ3aWR0aFwiOiBcIndcIlxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuRXhwcmVzc2lvbi5CT1VORFJZID0gXCJbIF9dK1wiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXhwcmVzc2lvbiA9IChFeHByZXNzaW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmRpdGlvbi5qc1xuZnVuY3Rpb24gY29uZGl0aW9uX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY29uZGl0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGNvbmRpdGlvbl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNvbmRpdGlvbl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gY29uZGl0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvblN0ciAtIGEgY29uZGl0aW9uIGluIHN0cmluZyBmb3JtYXRcbiAqIEBjbGFzcyBDb25kaXRpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBub3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZigpLndpZHRoKCBcIj5cIiwgMTAwMCkuYW5kKCkuYXNwZWN0UmF0aW8oXCI8XCIsIFwiMzo0XCIpLnRoZW4oKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKVxuICogICAgLmlmKFwidyA+IDEwMDAgYW5kIGFzcGVjdFJhdGlvIDwgMzo0XCIpXG4gKiAgICAgIC53aWR0aCgxMDAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKiAgICAuZWxzZSgpXG4gKiAgICAgIC53aWR0aCg1MDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqXG4gKi9cblxudmFyIENvbmRpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V4cHJlc3Npb24pIHtcbiAgX2luaGVyaXRzKENvbmRpdGlvbiwgX0V4cHJlc3Npb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29uZGl0aW9uKTtcblxuICBmdW5jdGlvbiBDb25kaXRpb24oY29uZGl0aW9uU3RyKSB7XG4gICAgY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmRpdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZGl0aW9uU3RyKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNoZWlnaHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAqL1xuXG5cbiAgY29uZGl0aW9uX2NyZWF0ZUNsYXNzKENvbmRpdGlvbiwgW3tcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImhcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwid1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJhclwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcInBjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZmNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZHVcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNpbml0aWFsRHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsRHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbER1cmF0aW9uKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaWR1XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmRpdGlvbjtcbn0oZXhwcmVzc2lvbik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmRpdGlvbiA9IChDb25kaXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlndXJhdGlvbi5qc1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIERlcGVuZHMgb24gJ3V0aWxzJ1xuICovXG5cbi8qKlxuICogQ2xhc3MgZm9yIGRlZmluaW5nIGFjY291bnQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIENvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGFjY291bnQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIHNldC5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICogIHRhcmdldD1cIl9uZXdcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICovXG5cbnZhciBjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25maWd1cmF0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRpb24pO1xuXG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKG9wdGlvbnMpO1xuICAgIGRlZmF1bHRzKHRoaXMuY29uZmlndXJhdGlvbiwgREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb25maWd1cmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGludm9rZXMgYm90aFxuICAgKiAge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfSAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KVxuICAgKiAgYW5kIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudHxmcm9tRG9jdW1lbnQoKX0uXG4gICAqICBJdCBmaXJzdCB0cmllcyB0byByZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jaW5pdFxuICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufSByZXR1cm5zIGB0aGlzYCBmb3IgY2hhaW5pbmdcbiAgICogQHNlZSBmcm9tRG9jdW1lbnRcbiAgICogQHNlZSBmcm9tRW52aXJvbm1lbnRcbiAgICovXG5cblxuICBjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRpb24sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZnJvbUVudmlyb25tZW50KCk7XG4gICAgICB0aGlzLmZyb21Eb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gICAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn1cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb25maWd1cmF0aW9uW25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2dldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gc2V0XG4gICAgICogQHJldHVybiB7Kn0gdGhlIGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShjb25maWcpIHtcbiAgICAgIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkodGhpcy5jb25maWd1cmF0aW9uLCBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKGNvbmZpZykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIEhUTUwgbWV0YSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudFxuICAgICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259XG4gICAgICogQGV4YW1wbGUgPG1ldGEgbmFtZT1cImNsb3VkaW5hcnlfY2xvdWRfbmFtZVwiIGNvbnRlbnQ9XCJteWNsb3VkXCI+XG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21Eb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRG9jdW1lbnQoKSB7XG4gICAgICB2YXIgZWwsIGksIGxlbiwgbWV0YV9lbGVtZW50cztcbiAgICAgIG1ldGFfZWxlbWVudHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdtZXRhW25hbWVePVwiY2xvdWRpbmFyeV9cIl0nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKG1ldGFfZWxlbWVudHMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbWV0YV9lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGVsID0gbWV0YV9lbGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bZWwuZ2V0QXR0cmlidXRlKCduYW1lJykucmVwbGFjZSgnY2xvdWRpbmFyeV8nLCAnJyldID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIHRoZSBgQ0xPVURJTkFSWV9VUkxgIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgcnVuIHVuZGVyIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50XG4gICAgICogQHJlcXVpcmVzIE5vZGUuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21FbnZpcm9ubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRW52aXJvbm1lbnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xvdWRpbmFyeV91cmwsIHF1ZXJ5LCB1cmksIHVyaVJlZ2V4O1xuXG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTCkge1xuICAgICAgICBjbG91ZGluYXJ5X3VybCA9IHByb2Nlc3MuZW52LkNMT1VESU5BUllfVVJMO1xuICAgICAgICB1cmlSZWdleCA9IC9jbG91ZGluYXJ5OlxcL1xcLyg/OihcXHcrKSg/OlxcOihbXFx3LV0rKSk/QCk/KFtcXHdcXC4tXSspKD86XFwvKFteP10qKSk/KD86XFw/KC4rKSk/LztcbiAgICAgICAgdXJpID0gdXJpUmVnZXguZXhlYyhjbG91ZGluYXJ5X3VybCk7XG5cbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgIGlmICh1cmlbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydjbG91ZF9uYW1lJ10gPSB1cmlbM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2FwaV9rZXknXSA9IHVyaVsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXJpWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX3NlY3JldCddID0gdXJpWzJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cmlbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydwcml2YXRlX2NkbiddID0gdXJpWzRdICE9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ3NlY3VyZV9kaXN0cmlidXRpb24nXSA9IHVyaVs0XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxdWVyeSA9IHVyaVs1XTtcblxuICAgICAgICAgIGlmIChxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnPScpLFxuICAgICAgICAgICAgICAgICAgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMiksXG4gICAgICAgICAgICAgICAgICBrID0gX3ZhbHVlJHNwbGl0MlswXSxcbiAgICAgICAgICAgICAgICAgIHYgPSBfdmFsdWUkc3BsaXQyWzFdO1xuXG4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb25ba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3IgbW9kaWZ5IHRoZSBDbG91ZGluYXJ5IGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBgY29uZmlnKClgIHJldHVybnMgdGhlIGFjdHVhbCBpbnRlcm5hbCBjb25maWd1cmF0aW9uIG9iamVjdC4gbW9kaWZ5aW5nIGl0IHdpbGwgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgbWV0aG9kLiBGb3IgbmV3IGNvZGUsIHVzZSBnZXQoKSwgbWVyZ2UoKSBldGMuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jY29uZmlnXG4gICAgICogQHBhcmFtIHtoYXNofHN0cmluZ3xib29sZWFufSBuZXdfY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld192YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBjb25maWd1cmF0aW9uLCBvciB2YWx1ZVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUVudmlyb25tZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbURvY3VtZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgSFRNTCBtZXRhIHRhZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWcobmV3X2NvbmZpZywgbmV3X3ZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgbmV3X3ZhbHVlID09PSB2b2lkIDA6XG4gICAgICAgICAgdGhpcy5zZXQobmV3X2NvbmZpZywgbmV3X3ZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG5ld19jb25maWcpOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZXdfY29uZmlnKTtcblxuICAgICAgICBjYXNlICFpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgdGhpcy5tZXJnZShuZXdfY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIHJldHVybiB0aGUgaW50ZXJuYWwgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEga2V5OnZhbHVlIGNvbGxlY3Rpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKHRoaXMuY29uZmlndXJhdGlvbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmZpZ3VyYXRpb247XG59KCk7XG5cbnZhciBERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TID0ge1xuICByZXNwb25zaXZlX2NsYXNzOiAnY2xkLXJlc3BvbnNpdmUnLFxuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50czogdHJ1ZSxcbiAgcm91bmRfZHByOiB0cnVlLFxuICBzZWN1cmU6ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5sb2NhdGlvbiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA6IHZvaWQgMCA6IHZvaWQgMCkgPT09ICdodHRwczonXG59O1xuY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uLkNPTkZJR19QQVJBTVMgPSBbXCJhcGlfa2V5XCIsIFwiYXBpX3NlY3JldFwiLCBcImNhbGxiYWNrXCIsIFwiY2RuX3N1YmRvbWFpblwiLCBcImNsb3VkX25hbWVcIiwgXCJjbmFtZVwiLCBcInByaXZhdGVfY2RuXCIsIFwicHJvdG9jb2xcIiwgXCJyZXNvdXJjZV90eXBlXCIsIFwicmVzcG9uc2l2ZVwiLCBcInJlc3BvbnNpdmVfY2xhc3NcIiwgXCJyZXNwb25zaXZlX3VzZV9icmVha3BvaW50c1wiLCBcInJlc3BvbnNpdmVfd2lkdGhcIiwgXCJyb3VuZF9kcHJcIiwgXCJzZWN1cmVcIiwgXCJzZWN1cmVfY2RuX3N1YmRvbWFpblwiLCBcInNlY3VyZV9kaXN0cmlidXRpb25cIiwgXCJzaG9ydGVuXCIsIFwidHlwZVwiLCBcInVwbG9hZF9wcmVzZXRcIiwgXCJ1cmxfc3VmZml4XCIsIFwidXNlX3Jvb3RfcGF0aFwiLCBcInZlcnNpb25cIiwgXCJleHRlcm5hbExpYnJhcmllc1wiLCBcIm1heF90aW1lb3V0X21zXCJdO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NvbmZpZ3VyYXRpb24gPSAoY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2xheWVyLmpzXG5mdW5jdGlvbiBsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxudmFyIGxheWVyX0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIExheWVyXG4gICAqIEBjb25zdHJ1Y3RvciBMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXIpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBbXCJyZXNvdXJjZVR5cGVcIiwgXCJ0eXBlXCIsIFwicHVibGljSWRcIiwgXCJmb3JtYXRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zW2tleV0gPSAocmVmID0gb3B0aW9uc1trZXldKSAhPSBudWxsID8gcmVmIDogb3B0aW9uc1tzbmFrZUNhc2Uoa2V5KV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBsYXllcl9jcmVhdGVDbGFzcyhMYXllciwgW3tcbiAgICBrZXk6IFwicmVzb3VyY2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc291cmNlVHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaWNJZCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnB1YmxpY0lkID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgSUQsIGZvcm1hdHRlZCBmb3IgbGF5ZXIgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldFB1YmxpY0lkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBwdWJsaWMgSURcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY0lkKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5vcHRpb25zLnB1YmxpY0lkKSAhPSBudWxsID8gcmVmLnJlcGxhY2UoL1xcLy9nLCBcIjpcIikgOiB2b2lkIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIElELCB3aXRoIGZvcm1hdCBpZiBwcmVzZW50XG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldEZ1bGxQdWJsaWNJZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gcHVibGljIElEXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsUHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFB1YmxpY0lkKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQdWJsaWNJZCgpICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuZm9ybWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljSWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI3RvU3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnB1YmxpY0lkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBwdWJsaWNJZFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnR5cGUgPT09IFwidXBsb2FkXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLmdldEZ1bGxQdWJsaWNJZCgpKTtcbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIjpcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsYXllcl9sYXllciA9IChsYXllcl9MYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci90ZXh0bGF5ZXIuanNcbmZ1bmN0aW9uIHRleHRsYXllcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHRleHRsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCB0ZXh0bGF5ZXJfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0ZXh0bGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG52YXIgdGV4dGxheWVyX1RleHRMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xheWVyKSB7XG4gIHRleHRsYXllcl9pbmhlcml0cyhUZXh0TGF5ZXIsIF9MYXllcik7XG5cbiAgdmFyIF9zdXBlciA9IHRleHRsYXllcl9jcmVhdGVTdXBlcihUZXh0TGF5ZXIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgVGV4dExheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gVGV4dExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dExheWVyKTtcblxuICAgIHZhciBrZXlzO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtcInJlc291cmNlVHlwZVwiLCBcInJlc291cmNlVHlwZVwiLCBcImZvbnRGYW1pbHlcIiwgXCJmb250U2l6ZVwiLCBcImZvbnRXZWlnaHRcIiwgXCJmb250U3R5bGVcIiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHRBbGlnblwiLCBcInN0cm9rZVwiLCBcImxldHRlclNwYWNpbmdcIiwgXCJsaW5lU3BhY2luZ1wiLCBcImZvbnRIaW50aW5nXCIsIFwiZm9udEFudGlhbGlhc2luZ1wiLCBcInRleHRcIiwgXCJ0ZXh0U3R5bGVcIl07XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9uc1trZXldID0gKHJlZiA9IG9wdGlvbnNba2V5XSkgIT0gbnVsbCA/IHJlZiA6IG9wdGlvbnNbc25ha2VDYXNlKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInRleHRcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoVGV4dExheWVyLCBbe1xuICAgIGtleTogXCJyZXNvdXJjZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb3VyY2VUeXBlKF9yZXNvdXJjZVR5cGUpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSByZXNvdXJjZVR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZShfdHlwZSkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IHR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoX2Zvcm1hdCkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IGZvcm1hdCBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEZhbWlseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250RmFtaWx5KF9mb250RmFtaWx5KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEZhbWlseSA9IF9mb250RmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRTaXplKF9mb250U2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRTaXplID0gX2ZvbnRTaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRXZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFdlaWdodChfZm9udFdlaWdodCkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRXZWlnaHQgPSBfZm9udFdlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFN0eWxlKF9mb250U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250U3R5bGUgPSBfZm9udFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHREZWNvcmF0aW9uKF90ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uID0gX3RleHREZWNvcmF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRBbGlnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QWxpZ24oX3RleHRBbGlnbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHRBbGlnbiA9IF90ZXh0QWxpZ247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cm9rZShfc3Ryb2tlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc3Ryb2tlID0gX3N0cm9rZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldHRlclNwYWNpbmcoX2xldHRlclNwYWNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nID0gX2xldHRlclNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGluZVNwYWNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZVNwYWNpbmcoX2xpbmVTcGFjaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcgPSBfbGluZVNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEhpbnRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEhpbnRpbmcoX2ZvbnRIaW50aW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcgPSBfZm9udEhpbnRpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEFudGlhbGlhc2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250QW50aWFsaWFzaW5nKF9mb250QW50aWFsaWFzaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyA9IF9mb250QW50aWFsaWFzaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHQgPSBfdGV4dDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlKF90ZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0U3R5bGUgPSBfdGV4dFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIFRleHRMYXllciN0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHMsIGhhc1B1YmxpY0lkLCBoYXNTdHlsZSwgcHVibGljSWQsIHJlLCByZXMsIHN0YXJ0LCBzdHlsZSwgdGV4dCwgdGV4dFNvdXJjZTtcbiAgICAgIHN0eWxlID0gdGhpcy50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGljSWQgIT0gbnVsbCkge1xuICAgICAgICBwdWJsaWNJZCA9IHRoaXMuZ2V0RnVsbFB1YmxpY0lkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGhhc1B1YmxpY0lkID0gIWlzRW1wdHkocHVibGljSWQpO1xuICAgICAgICBoYXNTdHlsZSA9ICFpc0VtcHR5KHN0eWxlKTtcblxuICAgICAgICBpZiAoaGFzUHVibGljSWQgJiYgaGFzU3R5bGUgfHwgIWhhc1B1YmxpY0lkICYmICFoYXNTdHlsZSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZWl0aGVyIHN0eWxlIHBhcmFtZXRlcnMgb3IgYSBwdWJsaWNfaWQgd2hlbiBwcm92aWRpbmcgdGV4dCBwYXJhbWV0ZXIgaW4gYSB0ZXh0IG92ZXJsYXkvdW5kZXJsYXksIGJ1dCBub3QgYm90aCFcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlID0gL1xcJFxcKFthLXpBLVpdXFx3KlxcKS9nO1xuICAgICAgICBzdGFydCA9IDA7IC8vICAgICAgICB0ZXh0U291cmNlID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLC9dXCIsICdnJyksIChjKS0+IFwiJSN7Yy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfVwiKVxuXG4gICAgICAgIHRleHRTb3VyY2UgPSBzbWFydEVzY2FwZSh0aGlzLm9wdGlvbnMudGV4dCwgL1ssXFwvXS9nKTtcbiAgICAgICAgdGV4dCA9IFwiXCI7XG5cbiAgICAgICAgd2hpbGUgKHJlcyA9IHJlLmV4ZWModGV4dFNvdXJjZSkpIHtcbiAgICAgICAgICB0ZXh0ICs9IHNtYXJ0RXNjYXBlKHRleHRTb3VyY2Uuc2xpY2Uoc3RhcnQsIHJlcy5pbmRleCkpO1xuICAgICAgICAgIHRleHQgKz0gcmVzWzBdO1xuICAgICAgICAgIHN0YXJ0ID0gcmVzLmluZGV4ICsgcmVzWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgKz0gc21hcnRFc2NhcGUodGV4dFNvdXJjZS5zbGljZShzdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzID0gW3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUsIHN0eWxlLCBwdWJsaWNJZCwgdGV4dF07XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVJZGVudGlmaWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZUlkZW50aWZpZXIoKSB7XG4gICAgICAvLyBOb3RlOiBpZiBhIHRleHQtc3R5bGUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYXMgYSB3aG9sZSwgaXQgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcgZWxzZSwgbm8gbWl4IGFuZCBtYXRjaC5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMudGV4dFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRleHRTdHlsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHM7XG4gICAgICBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRXZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24gIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnRleHRBbGlnbik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnN0cm9rZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGlzRW1wdHkodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJsZXR0ZXJfc3BhY2luZ19cIiArIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoaXNFbXB0eSh0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKSkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwibGluZV9zcGFjaW5nX1wiICsgdGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJhbnRpYWxpYXNfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImhpbnRpbmdfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkoY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpKSkge1xuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEZhbWlseSkpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGZvbnRGYW1pbHkuIFwiLmNvbmNhdChjb21wb25lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250U2l6ZSkgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMuZm9udFNpemUpKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBmb250U2l6ZS5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnVuc2hpZnQodGhpcy5vcHRpb25zLmZvbnRGYW1pbHksIHRoaXMub3B0aW9ucy5mb250U2l6ZSk7XG4gICAgICBjb21wb25lbnRzID0gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCJfXCIpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRMYXllcjtcbn0obGF5ZXJfbGF5ZXIpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0ZXh0bGF5ZXIgPSAodGV4dGxheWVyX1RleHRMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9zdWJ0aXRsZXNsYXllci5qc1xuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzdWJ0aXRsZXNsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBzdWJ0aXRsZXNsYXllcl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoc3VidGl0bGVzbGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIFN1YnRpdGxlc0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dExheWVyKSB7XG4gIHN1YnRpdGxlc2xheWVyX2luaGVyaXRzKFN1YnRpdGxlc0xheWVyLCBfVGV4dExheWVyKTtcblxuICB2YXIgX3N1cGVyID0gc3VidGl0bGVzbGF5ZXJfY3JlYXRlU3VwZXIoU3VidGl0bGVzTGF5ZXIpO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzdWJ0aXRsZXMgbGF5ZXJcbiAgICogQGNvbnN0cnVjdG9yIFN1YnRpdGxlc0xheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gU3VidGl0bGVzTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIHN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0xheWVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInN1YnRpdGxlc1wiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyhTdWJ0aXRsZXNMYXllcik7XG59KHRleHRsYXllcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN1YnRpdGxlc2xheWVyID0gKFN1YnRpdGxlc0xheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2ZldGNobGF5ZXIuanNcbmZ1bmN0aW9uIGZldGNobGF5ZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBmZXRjaGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGZldGNobGF5ZXJfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoZmV0Y2hsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cbnZhciBmZXRjaGxheWVyX0ZldGNoTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MYXllcikge1xuICBmZXRjaGxheWVyX2luaGVyaXRzKEZldGNoTGF5ZXIsIF9MYXllcik7XG5cbiAgdmFyIF9zdXBlciA9IGZldGNobGF5ZXJfY3JlYXRlU3VwZXIoRmV0Y2hMYXllcik7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBGZXRjaExheWVyXG4gICAqIEBjbGFzc2Rlc2MgQ3JlYXRlcyBhbiBpbWFnZSBsYXllciB1c2luZyBhIHJlbW90ZSBVUkwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnMgb3IgYSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsIHRoZSB1cmwgb2YgdGhlIGltYWdlIHRvIGZldGNoXG4gICAqL1xuICBmdW5jdGlvbiBGZXRjaExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZldGNoTGF5ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgX3RoaXMub3B0aW9ucy51cmwgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy51cmwgOiB2b2lkIDApIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyhGZXRjaExheWVyLCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXJsKF91cmwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51cmwgPSBfdXJsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIEZldGNoTGF5ZXIjdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcImZldGNoOlwiLmNvbmNhdChiYXNlNjRFbmNvZGVVUkwodGhpcy5vcHRpb25zLnVybCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZXRjaExheWVyO1xufShsYXllcl9sYXllcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZldGNobGF5ZXIgPSAoZmV0Y2hsYXllcl9GZXRjaExheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwYXJhbWV0ZXJzX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHBhcmFtZXRlcnNfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YobywgcCkgeyBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHBhcmFtZXRlcnNfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pIHsgcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnNcbiAqIERlcGVuZHMgb24gJ3V0aWwnLCAndHJhbnNmb3JtYXRpb24nXG4gKi9cblxudmFyIHBhcmFtZXRlcnNfUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYXJhbWV0ZXIuXG4gICAqIEBjbGFzcyBQYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jbmFtZVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXJhbSNzaG9ydE5hbWVcbiAgICAgKi9cblxuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgIC8qKlxuICAgICAqIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259IFBhcmFtI3Byb2Nlc3NcbiAgICAgKi9cblxuICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhICh1bnByb2Nlc3NlZCkgdmFsdWUgZm9yIHRoaXMgcGFyYW1ldGVyXG4gICAqIEBmdW5jdGlvbiBQYXJhbSNzZXRcbiAgICogQHBhcmFtIHsqfSBvcmlnVmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIHtQYXJhbX0gc2VsZiBmb3IgY2hhaW5pbmdcbiAgICovXG5cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFBhcmFtLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZSkge1xuICAgICAgdGhpcy5vcmlnVmFsdWUgPSBvcmlnVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHZhbCwgdmFsaWQ7XG4gICAgICB2YWwgPSB0aGlzLnZhbHVlKCk7XG4gICAgICB2YWxpZCA9IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWwpIHx8IGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh2YWwpIHx8IGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHZhbCkgPyAhaXNFbXB0eSh2YWwpIDogdmFsICE9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnNob3J0TmFtZSAhPSBudWxsICYmIHZhbGlkKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHByb2Nlc3NlZCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3ZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5vcm1fY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybV9jb2xvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS5yZXBsYWNlKC9eIy8sICdyZ2I6JykgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkX2FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkX2FycmF5KGFyZykge1xuICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbYXJnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBDb3ZlcnQgdmFsdWUgdG8gdmlkZW8gY29kZWMgc3RyaW5nLlxuICAgICpcbiAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0LFxuICAgICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IHBhcmFtIC0gdGhlIHZpZGVvIGNvZGVjIGFzIGVpdGhlciBhIFN0cmluZyBvciBhIEhhc2hcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHZpZGVvIGNvZGVjIHN0cmluZyBpbiB0aGUgZm9ybWF0IGNvZGVjOnByb2ZpbGU6bGV2ZWw6Yl9mcmFtZXNcbiAgICAqIEBleGFtcGxlXG4gICAgKiB2Y19bIDpwcm9maWxlIDogW2xldmVsIDogW2JfZnJhbWVzXV1dXG4gICAgKiBvclxuICAgICAgeyBjb2RlYzogJ2gyNjQnLCBwcm9maWxlOiAnYmFzaWMnLCBsZXZlbDogJzMuMScsIGJfZnJhbWVzOiBmYWxzZSB9XG4gICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzX3ZpZGVvX3BhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzX3ZpZGVvX3BhcmFtcyhwYXJhbSkge1xuICAgICAgdmFyIHZpZGVvO1xuXG4gICAgICBzd2l0Y2ggKHBhcmFtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHZpZGVvID0gXCJcIjtcblxuICAgICAgICAgIGlmICgnY29kZWMnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICB2aWRlbyA9IHBhcmFtLmNvZGVjO1xuXG4gICAgICAgICAgICBpZiAoJ3Byb2ZpbGUnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ucHJvZmlsZTtcblxuICAgICAgICAgICAgICBpZiAoJ2xldmVsJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ubGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoJ2JfZnJhbWVzJyBpbiBwYXJhbSAmJiBwYXJhbS5iX2ZyYW1lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOmJmcmFtZXNfbm9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlkZW87XG5cbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHBhcmFtO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhcmFtO1xufSgpO1xuXG52YXIgcGFyYW1ldGVyc19BcnJheVBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0pIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhBcnJheVBhcmFtLCBfUGFyYW0pO1xuXG4gIHZhciBfc3VwZXIgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKEFycmF5UGFyYW0pO1xuXG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBBcnJheVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5UGFyYW0pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICAgIF90aGlzLnNlcCA9IHNlcDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEFycmF5UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5zaG9ydE5hbWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJyYXlWYWx1ZSA9IHRoaXMudmFsdWUoKTtcblxuICAgICAgICBpZiAoaXNFbXB0eShhcnJheVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShhcnJheVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdChhcnJheVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmxhdCA9IGFycmF5VmFsdWUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHQuc2VyaWFsaXplKSA/IHQuc2VyaWFsaXplKCkgOiB0O1xuICAgICAgICAgIH0pLmpvaW4odGhpcy5zZXApO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdChmbGF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnVmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9jZXNzKHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZSkge1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PSBudWxsIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoQXJyYXlQYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIG9yaWdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEFycmF5UGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBbb3JpZ1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFycmF5UGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0yKSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoVHJhbnNmb3JtYXRpb25QYXJhbSwgX1BhcmFtMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKFRyYW5zZm9ybWF0aW9uUGFyYW0pO1xuXG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nob3J0TmFtZT0ndCddIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uUGFyYW0obmFtZSkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICB2YXIgc2hvcnROYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcInRcIjtcbiAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIyLmNhbGwodGhpcywgbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzKTtcbiAgICBfdGhpczMuc2VwID0gc2VwO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBlaXRoZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICAgKi9cblxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25QYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZSgpO1xuXG4gICAgICBpZiAoaXNFbXB0eSh2YWwpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IC8vIHZhbCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNvIGpvaW4gdGhlbVxuXG5cbiAgICAgIGlmIChiYXNldXRpbF9hbGxTdHJpbmdzKHZhbCkpIHtcbiAgICAgICAgdmFyIGpvaW5lZCA9IHZhbC5qb2luKHRoaXMuc2VwKTsgLy8gY3JlYXRlcyB0MS50Mi50MyBpbiBjYXNlIG11bHRpcGxlIG5hbWVkIHRyYW5zZm9ybWF0aW9ucyB3ZXJlIGNvbmZpZ3VyZWRcblxuICAgICAgICBpZiAoIWlzRW1wdHkoam9pbmVkKSkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiB3YXMgbm90IHNldCB3aXRoIGFuIGVtcHR5IHN0cmluZyAodmFsICE9IFsnJ10pO1xuICAgICAgICAgIHJlc3VsdCA9IFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGpvaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgdmFsIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgcmVzdWx0ID0gdmFsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF90aGlzNC5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodCkgJiYgIWlzRW1wdHkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKHQpLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUxKSB7XG4gICAgICB0aGlzLm9yaWdWYWx1ZSA9IG9yaWdWYWx1ZTE7XG5cbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYXRpb25QYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMub3JpZ1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYXRpb25QYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIFt0aGlzLm9yaWdWYWx1ZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm1hdGlvblBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIG51bWJlcl9wYXR0ZXJuID0gXCIoWzAtOV0qKVxcXFwuKFswLTldKyl8KFswLTldKylcIjtcbnZhciBvZmZzZXRfYW55X3BhdHRlcm4gPSBcIihcIiArIG51bWJlcl9wYXR0ZXJuICsgXCIpKFslcFBdKT9cIjtcblxudmFyIHBhcmFtZXRlcnNfUmFuZ2VQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMykge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFJhbmdlUGFyYW0sIF9QYXJhbTMpO1xuXG4gIHZhciBfc3VwZXIzID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihSYW5nZVBhcmFtKTtcblxuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1ub3JtX3JhbmdlX3ZhbHVlIF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgUmFuZ2VQYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZVBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBSYW5nZVBhcmFtLm5vcm1fcmFuZ2VfdmFsdWU7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlUGFyYW0pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhSYW5nZVBhcmFtLCBudWxsLCBbe1xuICAgIGtleTogXCJub3JtX3JhbmdlX3ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1fcmFuZ2VfdmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBTdHJpbmcodmFsdWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgb2Zmc2V0X2FueV9wYXR0ZXJuICsgJyQnKSk7XG5cbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyID0gb2Zmc2V0WzVdICE9IG51bGwgPyAncCcgOiAnJztcbiAgICAgICAgdmFsdWUgPSAob2Zmc2V0WzFdIHx8IG9mZnNldFs0XSkgKyBtb2RpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2VQYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBwYXJhbWV0ZXJzX1Jhd1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW00KSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoUmF3UGFyYW0sIF9QYXJhbTQpO1xuXG4gIHZhciBfc3VwZXI0ID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihSYXdQYXJhbSk7XG5cbiAgZnVuY3Rpb24gUmF3UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdQYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsIG5hbWUsIHNob3J0TmFtZSwgcHJvY2Vzcyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFJhd1BhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmF3UGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19MYXllclBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW01KSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoTGF5ZXJQYXJhbSwgX1BhcmFtNSk7XG5cbiAgdmFyIF9zdXBlcjUgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKExheWVyUGFyYW0pO1xuXG4gIGZ1bmN0aW9uIExheWVyUGFyYW0oKSB7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllclBhcmFtKTtcblxuICAgIHJldHVybiBfc3VwZXI1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKExheWVyUGFyYW0sIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IC8vIFBhcnNlIGxheWVyIG9wdGlvbnNcbiAgICAvLyBAcmV0dXJuIFtzdHJpbmddIGxheWVyIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgIC8vIEBwcml2YXRlXG4gICAgZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5vcmlnVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICh0aGlzLm9yaWdWYWx1ZSBpbnN0YW5jZW9mIGxheWVyX2xheWVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHZhciBsYXllck9wdGlvbnMgPSB3aXRoQ2FtZWxDYXNlS2V5cyh0aGlzLm9yaWdWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwidGV4dFwiIHx8IGxheWVyT3B0aW9ucy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgdGV4dGxheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJzdWJ0aXRsZXNcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBzdWJ0aXRsZXNsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwiZmV0Y2hcIiB8fCBsYXllck9wdGlvbnMudXJsICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBsYXllcl9sYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICBpZiAoL15mZXRjaDouKy8udGVzdCh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcih0aGlzLm9yaWdWYWx1ZS5zdWJzdHIoNikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInRleHRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGUobGF5ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgdGV4dGxheWVyKGxheWVyKS50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVyUGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19FeHByZXNzaW9uUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTYpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhFeHByZXNzaW9uUGFyYW0sIF9QYXJhbTYpO1xuXG4gIHZhciBfc3VwZXI2ID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihFeHByZXNzaW9uUGFyYW0pO1xuXG4gIGZ1bmN0aW9uIEV4cHJlc3Npb25QYXJhbSgpIHtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cHJlc3Npb25QYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhFeHByZXNzaW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUoX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEV4cHJlc3Npb25QYXJhbS5wcm90b3R5cGUpLCBcInNlcmlhbGl6ZVwiLCB0aGlzKS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwcmVzc2lvblBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmFuc2Zvcm1hdGlvbi5qc1xuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCB0cmFuc2Zvcm1hdGlvbl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCkgeyB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodHJhbnNmb3JtYXRpb25fdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKSB7IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCB0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cbi8qKlxuICogQXNzaWduIGtleSwgdmFsdWUgdG8gdGFyZ2V0LCB3aGVuIHZhbHVlIGlzIG5vdCBudWxsLjxicj5cbiAqICAgVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSB0YXJnZXQhXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IHRoZSBvYmplY3QgdG8gYXNzaWduIHRoZSB2YWx1ZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VzIG9uZSBvciBtb3JlIG9iamVjdHMgdG8gZ2V0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdGFyZ2V0IGFmdGVyIHRoZSBhc3NpZ25tZW50XG4gKi9cblxuZnVuY3Rpb24gYXNzaWduTm90TnVsbCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHNvdXJjZVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uQmFzZVxuICogRGVwZW5kcyBvbiAnY29uZmlndXJhdGlvbicsICdwYXJhbWV0ZXJzJywndXRpbCdcbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBjbGFzcyBmb3IgdHJhbnNmb3JtYXRpb25zLlxuICAgKiBNZW1iZXJzIG9mIHRoaXMgY2xhc3MgYXJlIGRvY3VtZW50ZWQgYXMgYmVsb25naW5nIHRvIHRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IGNsYXNzIGZvciBjb252ZW5pZW5jZS5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uQmFzZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb25CYXNlKG9wdGlvbnMpIHtcbiAgICB0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm1hdGlvbkJhc2UpO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB2YXIgcGFyZW50LCB0cmFucztcbiAgICBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdHJhbnMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gaWRlbnRpY2FsIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyB0cmFuc2Zvcm1hdGlvblxuICAgICAqL1xuXG4gICAgdGhpcy50b09wdGlvbnMgPSBmdW5jdGlvbiAod2l0aENoYWluKSB7XG4gICAgICB2YXIgb3B0ID0ge307XG5cbiAgICAgIGlmICh3aXRoQ2hhaW4gPT0gbnVsbCkge1xuICAgICAgICB3aXRoQ2hhaW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyh0cmFucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRba2V5XSA9IHRyYW5zW2tleV0ub3JpZ1ZhbHVlO1xuICAgICAgfSk7XG4gICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuXG4gICAgICBpZiAod2l0aENoYWluICYmICFpc0VtcHR5KHRoaXMuY2hhaW5lZCkpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgIHJldHVybiB0ci50b09wdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucHVzaChvcHQpO1xuICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgYXNzaWduTm90TnVsbChvcHQsIHRoaXMub3RoZXJPcHRpb25zKTtcbiAgICAgICAgb3B0LnRyYW5zZm9ybWF0aW9uID0gbGlzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHBhcmVudCBmb3IgdGhpcyBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NldFBhcmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgcGFyZW50IHRvIGJlIGFzc2lnbmVkIHRvXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLnNldFBhcmVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHBhcmVudCA9IG9iamVjdDtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbU9wdGlvbnModHlwZW9mIG9iamVjdC50b09wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b09wdGlvbnMoKSA6IHZvaWQgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGluIHRoZSBjaGFpblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRQYXJlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3QgaWYgdGhlcmUgaXMgYW55XG4gICAgICovXG5cblxuICAgIHRoaXMuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9OyAvLyBIZWxwZXIgbWV0aG9kcyB0byBjcmVhdGUgcGFyYW1ldGVyIG1ldGhvZHNcbiAgICAvLyBUaGVzZSBtZXRob2RzIGFyZSBkZWZpbmVkIGhlcmUgYmVjYXVzZSB0aGV5IGFjY2VzcyBgdHJhbnNgIHdoaWNoIGlzXG4gICAgLy8gYSBwcml2YXRlIG1lbWJlciBvZiBgVHJhbnNmb3JtYXRpb25CYXNlYFxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5wYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBpZiAocHJvY2VzcyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHByb2Nlc3MgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5yYXdQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1Jhd1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMucmFuZ2VQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1JhbmdlUGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5hcnJheVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIjpcIjtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICAgICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfQXJyYXlQYXJhbShuYW1lLCBhYmJyLCBzZXAsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMudHJhbnNmb3JtYXRpb25QYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCIuXCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUsIGFiYnIsIHNlcCwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmxheWVyUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIpIHtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfTGF5ZXJQYXJhbShuYW1lLCBhYmJyKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTsgLy8gRW5kIEhlbHBlciBtZXRob2RzXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgcHJvY2Vzc2VkIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqIEBkZXNjcmlwdGlvbiBVc2Uge0BsaW5rIGdldH0ub3JpZ1ZhbHVlIGZvciB0aGUgdmFsdWUgb3JpZ2luYWxseSBwcm92aWRlZCBmb3IgdGhlIHBhcmFtZXRlclxuICAgICAqL1xuXG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zW25hbWVdICYmIHRyYW5zW25hbWVdLnZhbHVlKCk7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlciBvYmplY3QgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogQHJldHVybnMge1BhcmFtfSB0aGUgcGFyYW0gb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cmFuc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBmcm9tIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIG9wdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgbm8gb3B0aW9uIGJ5IHRoYXQgbmFtZSB3YXMgZm91bmQuIFRoZSB0eXBlIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICByZXR1cm5lZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB2YWx1ZS5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHRlbXA7XG5cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSB0cmFuc1tuYW1lXSA9PSBudWxsOlxuICAgICAgICAgIHRlbXAgPSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICBkZWxldGUgdHJhbnNbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRlbXAub3JpZ1ZhbHVlO1xuXG4gICAgICAgIGNhc2UgdGhpcy5vdGhlck9wdGlvbnNbbmFtZV0gPT0gbnVsbDpcbiAgICAgICAgICB0ZW1wID0gdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIHJldHVybiB0ZW1wO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBrZXlzIChvcHRpb24gbmFtZXMpIGluIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSB0aGUga2V5cyBpbiBzbmFrZUNhc2UgZm9ybWF0XG4gICAgICovXG5cblxuICAgIHRoaXMua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goa2V5Lm1hdGNoKFZBUl9OQU1FX1JFKSA/IGtleSA6IHNuYWtlQ2FzZShrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4gVmFsdWVzIGFyZSBwcm9jZXNzZWQuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvUGxhaW5PYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zIGFzIHBsYWluIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICB0aGlzLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFzaCwga2V5LCBsaXN0O1xuICAgICAgaGFzaCA9IHt9O1xuXG4gICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICBoYXNoW2tleV0gPSB0cmFuc1trZXldLnZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShoYXNoW2tleV0pKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShoYXNoW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLmNoYWluZWQpKSB7XG4gICAgICAgIGxpc3QgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgIHJldHVybiB0ci50b1BsYWluT2JqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0LnB1c2goaGFzaCk7XG4gICAgICAgIGhhc2ggPSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb246IGxpc3RcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhbmQgY2hhaW4gdG8gYSBuZXcgb25lLlxuICAgICAqIEluIHRoZSBVUkwsIHRyYW5zZm9ybWF0aW9ucyBhcmUgY2hhaW5lZCB0b2dldGhlciBieSBzbGFzaGVzLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNjaGFpblxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgdHJhbnNmb3JtYXRpb24gZm9yIGNoYWluaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpO1xuICAgICAqIHRyLndpZHRoKDEwKS5jcm9wKCdmaXQnKS5jaGFpbigpLmFuZ2xlKDE1KS5zZXJpYWxpemUoKVxuICAgICAqIC8vIHByb2R1Y2VzIFwiY19maXQsd18xMC9hXzE1XCJcbiAgICAgKi9cblxuXG4gICAgdGhpcy5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lcywgdHI7XG4gICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRyYW5zKTtcblxuICAgICAgaWYgKG5hbWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0ciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKGZhbHNlKSk7XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jaGFpbmVkLnB1c2godHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5vdGhlck9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNoYWluZWQgPSBbXTtcbiAgICB0aGlzLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgcHJvdmlkZWQgb3B0aW9ucyB3aXRoIG93bidzIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBrZXktdmFsdWUgbGlzdCBvZiBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKi9cblxuXG4gIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uQmFzZSwgW3tcbiAgICBrZXk6IFwiZnJvbU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIHRoaXMuZnJvbVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogb3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UgfHwgdmFsdWUgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIEhhbmRsaW5nIG9mIFwiaWZcIiBzdGF0ZW1lbnRzIHByZWNlZGVzIG90aGVyIG9wdGlvbnMgYXMgaXQgY3JlYXRlcyBhIGNoYWluZWQgdHJhbnNmb3JtYXRpb25cblxuICAgICAgICBpZiAob3B0aW9uc1tcImlmXCJdKSB7XG4gICAgICAgICAgdGhpcy5zZXQoXCJpZlwiLCBvcHRpb25zW1wiaWZcIl0pO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW1wiaWZcIl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zW2tleV07XG5cbiAgICAgICAgICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goVkFSX05BTUVfUkUpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09ICckYXR0cicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgndmFyaWFibGUnLCBrZXksIG9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21UcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVHJhbnNmb3JtYXRpb24ob3RoZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAgICAgICBvdGhlci5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIG90aGVyLmdldChrZXkpLm9yaWdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyYW1ldGVyLlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgbmFtZSBga2V5YCBpcyBjb252ZXJ0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5KSB7XG4gICAgICB2YXIgY2FtZWxLZXk7XG4gICAgICBjYW1lbEtleSA9IGNhbWVsQ2FzZShrZXkpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHZhbHVlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMsIGNhbWVsS2V5KSkge1xuICAgICAgICB0aGlzW2NhbWVsS2V5XS5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdGhlck9wdGlvbnNba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0xheWVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IHRoaXMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGlmUGFyYW0sIGosIGxlbiwgcGFyYW1MaXN0LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlc3VsdEFycmF5LCB0LCB0cmFuc2Zvcm1hdGlvbkxpc3QsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB0cmFuc2Zvcm1hdGlvbnMsIHZhbHVlLCB2YXJpYWJsZXMsIHZhcnM7XG4gICAgICByZXN1bHRBcnJheSA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5zZXJpYWxpemUoKTtcbiAgICAgIH0pO1xuICAgICAgcGFyYW1MaXN0ID0gdGhpcy5rZXlzKCk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMgPSAocmVmID0gdGhpcy5nZXQoXCJ0cmFuc2Zvcm1hdGlvblwiKSkgIT0gbnVsbCA/IHJlZi5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIGlmUGFyYW0gPSAocmVmMSA9IHRoaXMuZ2V0KFwiaWZcIikpICE9IG51bGwgPyByZWYxLnNlcmlhbGl6ZSgpIDogdm9pZCAwO1xuICAgICAgdmFyaWFibGVzID0gcHJvY2Vzc1ZhcigocmVmMiA9IHRoaXMuZ2V0KFwidmFyaWFibGVzXCIpKSAhPSBudWxsID8gcmVmMi52YWx1ZSgpIDogdm9pZCAwKTtcbiAgICAgIHBhcmFtTGlzdCA9IGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQoKShwYXJhbUxpc3QsIFtcInRyYW5zZm9ybWF0aW9uXCIsIFwiaWZcIiwgXCJ2YXJpYWJsZXNcIl0pO1xuICAgICAgdmFycyA9IFtdO1xuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gW107XG5cbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHBhcmFtTGlzdC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICB0ID0gcGFyYW1MaXN0W2pdO1xuXG4gICAgICAgIGlmICh0Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgIHZhcnMucHVzaCh0ICsgXCJfXCIgKyBleHByZXNzaW9uLm5vcm1hbGl6ZSgocmVmMyA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmMy52YWx1ZSgpIDogdm9pZCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goKHJlZjQgPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IHJlZjQuc2VyaWFsaXplKCkgOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25zKTpcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaCh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIWlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbnMpOlxuICAgICAgICAgIHJlc3VsdEFycmF5ID0gcmVzdWx0QXJyYXkuY29uY2F0KHRyYW5zZm9ybWF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGssIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdHJhbnNmb3JtYXRpb25MaXN0Lmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgIHZhbHVlID0gdHJhbnNmb3JtYXRpb25MaXN0W2tdO1xuXG4gICAgICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgJiYgIWlzRW1wdHkodmFsdWUpIHx8ICFpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpO1xuXG4gICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QgPSB2YXJzLnNvcnQoKS5jb25jYXQodmFyaWFibGVzKS5jb25jYXQodHJhbnNmb3JtYXRpb25MaXN0LnNvcnQoKSk7XG5cbiAgICAgIGlmIChpZlBhcmFtID09PSBcImlmX2VuZFwiKSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC5wdXNoKGlmUGFyYW0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eShpZlBhcmFtKSkge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QudW5zaGlmdChpZlBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25MaXN0KS5qb2luKHRoaXMucGFyYW1fc2VwYXJhdG9yKTtcblxuICAgICAgaWYgKCFpc0VtcHR5KHRyYW5zZm9ybWF0aW9uU3RyaW5nKSkge1xuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHRyYW5zZm9ybWF0aW9uU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShyZXN1bHRBcnJheSkuam9pbih0aGlzLnRyYW5zX3NlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBsaXN0IG9mIGFsbCB0aGUgdmFsaWQgdHJhbnNmb3JtYXRpb24gb3B0aW9uIG5hbWVzXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2xpc3ROYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gYSBhcnJheSBvZiBhbGwgdGhlIHZhbGlkIG9wdGlvbiBuYW1lc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sQXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIGFuIEhUTUwgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5LnRvSHRtbEF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJuIFBsYWluT2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IdG1sQXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYXR0ck5hbWUsIGhlaWdodCwgb3B0aW9ucywgcmVmMiwgcmVmMywgdmFsdWUsIHdpZHRoO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIHNuYWtlQ2FzZUtleTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3RoZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFsdWUgPSBfdGhpczIub3RoZXJPcHRpb25zW2tleV07XG4gICAgICAgIHNuYWtlQ2FzZUtleSA9IHNuYWtlQ2FzZShrZXkpO1xuXG4gICAgICAgIGlmICghaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVMsIHNuYWtlQ2FzZUtleSkgJiYgIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKFVSTF9LRVlTLCBzbmFrZUNhc2VLZXkpKSB7XG4gICAgICAgICAgYXR0ck5hbWUgPSAvXmh0bWxfLy50ZXN0KGtleSkgPyBrZXkuc2xpY2UoNSkgOiBrZXk7XG4gICAgICAgICAgb3B0aW9uc1thdHRyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGNvbnZlcnQgYWxsIFwiaHRtbF9rZXlcIiB0byBcImtleVwiIHdpdGggdGhlIHNhbWUgdmFsdWVcblxuICAgICAgdGhpcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgvXmh0bWxfLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICBvcHRpb25zW2NhbWVsQ2FzZShrZXkuc2xpY2UoNSkpXSA9IF90aGlzMi5nZXRWYWx1ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCEodGhpcy5oYXNMYXllcigpIHx8IHRoaXMuZ2V0VmFsdWUoXCJhbmdsZVwiKSB8fCBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShbXCJmaXRcIiwgXCJsaW1pdFwiLCBcImxmaWxsXCJdLCB0aGlzLmdldFZhbHVlKFwiY3JvcFwiKSkpKSB7XG4gICAgICAgIHdpZHRoID0gKHJlZjIgPSB0aGlzLmdldChcIndpZHRoXCIpKSAhPSBudWxsID8gcmVmMi5vcmlnVmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGhlaWdodCA9IChyZWYzID0gdGhpcy5nZXQoXCJoZWlnaHRcIikpICE9IG51bGwgPyByZWYzLm9yaWdWYWx1ZSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocGFyc2VGbG9hdCh3aWR0aCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KGhlaWdodCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgdG8gdGhlIHBhcmVudCAodXAgdGhlIGNhbGwgY2hhaW4pIHRvIHByb2R1Y2UgSFRNTFxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b0h0bWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhcmVudCBpZiBwb3NzaWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRhZyA9IGNsb3VkaW5hcnkuSW1hZ2VUYWcubmV3KFwic2FtcGxlXCIsIHtjbG91ZF9uYW1lOiBcImRlbW9cIn0pXG4gICAgICogLy8gSW1hZ2VUYWcge25hbWU6IFwiaW1nXCIsIHB1YmxpY0lkOiBcInNhbXBsZVwifVxuICAgICAqIHRhZy50b0h0bWwoKVxuICAgICAqIC8vIDxpbWcgc3JjPVwiaHR0cDovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC9zYW1wbGVcIj5cbiAgICAgKiB0YWcudHJhbnNmb3JtYXRpb24oKS5jcm9wKFwiZml0XCIpLndpZHRoKDMwMCkudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvY19maXQsd18zMDAvc2FtcGxlXCI+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IdG1sKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5nZXRQYXJlbnQoKSkgIT0gbnVsbCA/IHR5cGVvZiByZWYudG9IdG1sID09PSBcImZ1bmN0aW9uXCIgPyByZWYudG9IdG1sKCkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKHRydWUpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJsaXN0TmFtZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdE5hbWVzKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRQYXJhbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZFBhcmFtTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5pbmRleE9mKGNhbWVsQ2FzZShuYW1lKSkgPj0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtYXRpb25CYXNlO1xufSgpO1xuXG52YXIgVkFSX05BTUVfUkUgPSAvXlxcJFthLXpBLVowLTldKyQvO1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlLnByb3RvdHlwZS50cmFuc19zZXBhcmF0b3IgPSAnLyc7XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnBhcmFtX3NlcGFyYXRvciA9ICcsJztcblxuZnVuY3Rpb24gbGFzdEFyZ0NhbGxiYWNrKGFyZ3MpIHtcbiAgdmFyIGNhbGxiYWNrO1xuICBjYWxsYmFjayA9IGFyZ3MgIT0gbnVsbCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IHZvaWQgMDtcblxuICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NWYXIodmFyQXJyYXkpIHtcbiAgdmFyIGosIGxlbiwgbmFtZSwgcmVzdWx0cywgdjtcblxuICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhckFycmF5KSkge1xuICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHZhckFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgX3ZhckFycmF5JGogPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KHZhckFycmF5W2pdLCAyKTtcblxuICAgICAgbmFtZSA9IF92YXJBcnJheSRqWzBdO1xuICAgICAgdiA9IF92YXJBcnJheSRqWzFdO1xuICAgICAgcmVzdWx0cy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQoZXhwcmVzc2lvbi5ub3JtYWxpemUodikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFyQXJyYXk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0N1c3RvbUZ1bmN0aW9uKF9yZWYpIHtcbiAgdmFyIGZ1bmN0aW9uX3R5cGUgPSBfcmVmLmZ1bmN0aW9uX3R5cGUsXG4gICAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZTtcblxuICBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3JlbW90ZScpIHtcbiAgICByZXR1cm4gW2Z1bmN0aW9uX3R5cGUsIGJ0b2Eoc291cmNlKV0uam9pbihcIjpcIik7XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3dhc20nKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBzb3VyY2VdLmpvaW4oXCI6XCIpO1xuICB9XG59XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICogQGNvbnN0IFRyYW5zZm9ybWF0aW9uLm1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuXG4vKipcbiAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgZmlsdGVyZWQgb3V0IGJlZm9yZSBwYXNzaW5nIHRoZSBvcHRpb25zIHRvIGFuIEhUTUwgdGFnLlxuICpcbiAqIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaXMgYSBjb21iaW5hdGlvbiBvZiBgVHJhbnNmb3JtYXRpb246Om1ldGhvZHNgIGFuZCBgQ29uZmlndXJhdGlvbjo6Q09ORklHX1BBUkFNU2BcbiAqIEBjb25zdCB7QXJyYXk8c3RyaW5nPn0gVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAc2VlIHRvSHRtbEF0dHJpYnV0ZXNcbiAqL1xuXG5cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zZm9ybWF0aW9uQmFzZSkge1xuICB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhUcmFuc2Zvcm1hdGlvbiwgX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IHRyYW5zZm9ybWF0aW9uX2NyZWF0ZVN1cGVyKFRyYW5zZm9ybWF0aW9uKTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigpO1xuICAgKiB0LmFuZ2xlKDIwKS5jcm9wKFwic2NhbGVcIikud2lkdGgoXCJhdXRvXCIpO1xuICAgKlxuICAgKiAvLyBvclxuICAgKlxuICAgKiB0ID0gbmV3IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24oIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSk7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259XG4gICAqIEBleGFtcGxlIGNsID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSlcbiAgICovXG5cblxuICB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbiwgW3tcbiAgICBrZXk6IFwiYW5nbGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKlxuICAgICAgVHJhbnNmb3JtYXRpb24gUGFyYW1ldGVyc1xuICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiYW5nbGVcIiwgXCJhXCIsIFwiLlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fY29kZWNcIiwgXCJhY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9GcmVxdWVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9GcmVxdWVuY3kodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImF1ZGlvX2ZyZXF1ZW5jeVwiLCBcImFmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXNwZWN0X3JhdGlvXCIsIFwiYXJcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2tncm91bmQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJhY2tncm91bmRcIiwgXCJiXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpdFJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYml0UmF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYml0X3JhdGVcIiwgXCJiclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYm9yZGVyXCIsIFwiYm9cIiwgZnVuY3Rpb24gKGJvcmRlcikge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGJvcmRlcikpIHtcbiAgICAgICAgICBib3JkZXIgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCB7XG4gICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LCBib3JkZXIpO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChib3JkZXIud2lkdGgsIFwicHhfc29saWRfXCIpLmNvbmNhdChwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IoYm9yZGVyLmNvbG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvclwiLCBcImNvXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yU3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3JTcGFjZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY29sb3Jfc3BhY2VcIiwgXCJjc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcm9wKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjcm9wXCIsIFwiY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImN1c3RvbV9mdW5jdGlvblwiLCBcImZuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tUHJlRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tUHJlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnY3VzdG9tX2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJjdXN0b21fZnVuY3Rpb25cIiwgXCJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWx1ZSA9IHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFwiZm5fcHJlOlwiLmNvbmNhdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEltYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWZhdWx0X2ltYWdlXCIsIFwiZFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbGF5XCIsIFwiZGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbnNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVuc2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVuc2l0eVwiLCBcImRuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJkdXJhdGlvblwiLCBcImR1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHByKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkcHJcIiwgXCJkcHJcIiwgZnVuY3Rpb24gKGRwcikge1xuICAgICAgICBkcHIgPSBkcHIudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoZHByICE9IG51bGwgPyBkcHIubWF0Y2goL15cXGQrJC8pIDogdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGRwciArIFwiLjBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUoZHByKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVmZmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZmZlY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiZWZmZWN0XCIsIFwiZVwiLCBcIjpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbHNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbHNlKCkge1xuICAgICAgcmV0dXJuIHRoaXNbXCJpZlwiXSgnZWxzZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRJZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRJZigpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiaWZcIl0oJ2VuZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2Zmc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcImVuZF9vZmZzZXRcIiwgXCJlb1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZmFsbGJhY2tfY29udGVudFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hGb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZldGNoX2Zvcm1hdFwiLCBcImZcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmxhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxhZ3ModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiZmxhZ3NcIiwgXCJmbFwiLCBcIi5cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyYXZpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3Jhdml0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZ3Jhdml0eVwiLCBcImdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcHModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZwc1wiLCBcImZwc1wiLCBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShmcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZwcztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoZnBzKSkge1xuICAgICAgICAgIHJldHVybiBmcHMuam9pbihcIi1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZwcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJoZWlnaHRcIiwgXCJoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXMzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWxIZWlnaHQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfaGVpZ2h0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbFdpZHRoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJodG1sX3dpZHRoXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWYoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgICB2YXIgaSwgaWZWYWwsIGosIHJlZiwgdHJJZiwgdHJSZXN0O1xuXG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJlbHNlXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIik7XG5cbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHRoaXMuY2hhaW4oKTtcblxuICAgICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aGlzLmNoYWluZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBpID0gaiArPSAtMSkge1xuICAgICAgICAgICAgaWZWYWwgPSB0aGlzLmNoYWluZWRbaV0uZ2V0VmFsdWUoXCJpZlwiKTtcblxuICAgICAgICAgICAgaWYgKGlmVmFsID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZlZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRySWYgPSBUcmFuc2Zvcm1hdGlvbltcIm5ld1wiXSgpW1wiaWZcIl0oaWZWYWwpO1xuICAgICAgICAgICAgICB0aGlzLmNoYWluZWRbaV0ucmVtb3ZlKFwiaWZcIik7XG4gICAgICAgICAgICAgIHRyUmVzdCA9IHRoaXMuY2hhaW5lZFtpXTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKS50cmFuc2Zvcm1hdGlvbihbdHJJZiwgdHJSZXN0XSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlmVmFsICE9PSBcImVsc2VcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiKTtcblxuICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbltcIm5ld1wiXSgpLnNldFBhcmVudCh0aGlzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uW1wibmV3XCJdKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlmcmFtZUludGVydmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleWZyYW1lSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImtleWZyYW1lX2ludGVydmFsXCIsIFwia2lcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9jclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvY3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIm9jclwiLCBcIm9jclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZnNldCh2YWx1ZSkge1xuICAgICAgdmFyIGVuZF9vLCBzdGFydF9vO1xuXG4gICAgICB2YXIgX3JlZjIgPSBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSA/IHZhbHVlLnNwbGl0KCcuLicpIDogaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlIDogW251bGwsIG51bGxdO1xuXG4gICAgICB2YXIgX3JlZjMgPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KF9yZWYyLCAyKTtcblxuICAgICAgc3RhcnRfbyA9IF9yZWYzWzBdO1xuICAgICAgZW5kX28gPSBfcmVmM1sxXTtcblxuICAgICAgaWYgKHN0YXJ0X28gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0KHN0YXJ0X28pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kX28gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRPZmZzZXQoZW5kX28pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wYWNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIm9wYWNpdHlcIiwgXCJvXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3ZlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclBhcmFtKHZhbHVlLCBcIm92ZXJsYXlcIiwgXCJsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBhZ2VcIiwgXCJwZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3Rlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicG9zdGVyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZml4KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwcmVmaXhcIiwgXCJwXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWxpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInF1YWxpdHlcIiwgXCJxXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFkaXVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGl1cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJyYWRpdXNcIiwgXCJyXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhd1RyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhd1RyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJyYXdfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSkge1xuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJ3gnKTtcblxuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0MiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKTtcblxuICAgICAgICB3aWR0aCA9IF92YWx1ZSRzcGxpdDJbMF07XG4gICAgICAgIGhlaWdodCA9IF92YWx1ZSRzcGxpdDJbMV07XG4gICAgICAgIHRoaXMud2lkdGgod2lkdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQoaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90eXBlc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90cmFuc2Zvcm1hdGlvblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwic3RhcnRfb2Zmc2V0XCIsIFwic29cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbWluZ1Byb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtaW5nUHJvZmlsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwic3RyZWFtaW5nX3Byb2ZpbGVcIiwgXCJzcFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uUGFyYW0odmFsdWUsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmRlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJ1bmRlcmxheVwiLCBcInVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgbmFtZSwgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZXModmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlcywgXCJ2YXJpYWJsZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fY29kZWNcIiwgXCJ2Y1wiLCBwYXJhbWV0ZXJzX1BhcmFtLnByb2Nlc3NfdmlkZW9fcGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9TYW1wbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1NhbXBsaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ2aWRlb19zYW1wbGluZ1wiLCBcInZzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIndpZHRoXCIsIFwid1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczQuZ2V0VmFsdWUoXCJjcm9wXCIpIHx8IF90aGlzNC5nZXRWYWx1ZShcIm92ZXJsYXlcIikgfHwgX3RoaXM0LmdldFZhbHVlKFwidW5kZXJsYXlcIikpIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ4XCIsIFwieFwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwieVwiLCBcInlcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInpvb21cIiwgXCJ6XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm1hdGlvbjtcbn0odHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlKTtcbi8qKlxuICogVHJhbnNmb3JtYXRpb24gQ2xhc3MgbWV0aG9kcy5cbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQgaW4gVHJhbnNmb3JtYXRpb24uXG4gKiBWYWx1ZXMgYXJlIGNhbWVsQ2FzZWQuXG4gKi9cblxuXG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzID0gW1wiYW5nbGVcIiwgXCJhdWRpb0NvZGVjXCIsIFwiYXVkaW9GcmVxdWVuY3lcIiwgXCJhc3BlY3RSYXRpb1wiLCBcImJhY2tncm91bmRcIiwgXCJiaXRSYXRlXCIsIFwiYm9yZGVyXCIsIFwiY29sb3JcIiwgXCJjb2xvclNwYWNlXCIsIFwiY3JvcFwiLCBcImN1c3RvbUZ1bmN0aW9uXCIsIFwiY3VzdG9tUHJlRnVuY3Rpb25cIiwgXCJkZWZhdWx0SW1hZ2VcIiwgXCJkZWxheVwiLCBcImRlbnNpdHlcIiwgXCJkdXJhdGlvblwiLCBcImRwclwiLCBcImVmZmVjdFwiLCBcImVsc2VcIiwgXCJlbmRJZlwiLCBcImVuZE9mZnNldFwiLCBcImZhbGxiYWNrQ29udGVudFwiLCBcImZldGNoRm9ybWF0XCIsIFwiZm9ybWF0XCIsIFwiZmxhZ3NcIiwgXCJncmF2aXR5XCIsIFwiZnBzXCIsIFwiaGVpZ2h0XCIsIFwiaHRtbEhlaWdodFwiLCBcImh0bWxXaWR0aFwiLCBcImlmXCIsIFwia2V5ZnJhbWVJbnRlcnZhbFwiLCBcIm9jclwiLCBcIm9mZnNldFwiLCBcIm9wYWNpdHlcIiwgXCJvdmVybGF5XCIsIFwicGFnZVwiLCBcInBvc3RlclwiLCBcInByZWZpeFwiLCBcInF1YWxpdHlcIiwgXCJyYWRpdXNcIiwgXCJyYXdUcmFuc2Zvcm1hdGlvblwiLCBcInNpemVcIiwgXCJzb3VyY2VUeXBlc1wiLCBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJzdHJlYW1pbmdQcm9maWxlXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ1bmRlcmxheVwiLCBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVzXCIsIFwidmlkZW9Db2RlY1wiLCBcInZpZGVvU2FtcGxpbmdcIiwgXCJ3aWR0aFwiLCBcInhcIiwgXCJ5XCIsIFwiem9vbVwiXTtcbi8qKlxuICogUGFyYW1ldGVycyB0aGF0IGFyZSBmaWx0ZXJlZCBvdXQgYmVmb3JlIHBhc3NpbmcgdGhlIG9wdGlvbnMgdG8gYW4gSFRNTCB0YWcuXG4gKlxuICogVGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBpcyBhIGNvbWJpbmF0aW9uIG9mIGBUcmFuc2Zvcm1hdGlvbjo6bWV0aG9kc2AgYW5kIGBDb25maWd1cmF0aW9uOjpDT05GSUdfUEFSQU1TYFxuICovXG5cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTID0gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5tYXAoc25ha2VDYXNlKS5jb25jYXQoc3JjX2NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdHJhbnNmb3JtYXRpb24gPSAodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9odG1sdGFnLmpzXG5mdW5jdGlvbiBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gaHRtbHRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBHZW5lcmljIEhUTUwgdGFnXG4gKiBEZXBlbmRzIG9uICd0cmFuc2Zvcm1hdGlvbicsICd1dGlsJ1xuICovXG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgKERPTSkgdGFnXG4gKiBAY29uc3RydWN0b3IgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlIHRhZyA9IG5ldyBIdG1sVGFnKCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gKi9cblxudmFyIGh0bWx0YWdfSHRtbFRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEh0bWxUYWcobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUYWcpO1xuXG4gICAgdmFyIHRyYW5zZm9ybWF0aW9uO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wdWJsaWNJZCA9IHB1YmxpY0lkO1xuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwdWJsaWNJZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHB1YmxpY0lkO1xuICAgICAgICB0aGlzLnB1YmxpY0lkID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICB0cmFuc2Zvcm1hdGlvbi5zZXRQYXJlbnQodGhpcyk7XG5cbiAgICB0aGlzLnRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gSFRNTCAoRE9NKSB0YWdcbiAgICogQGZ1bmN0aW9uIEh0bWxUYWcubmV3XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHRhZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtIdG1sVGFnfVxuICAgKiBAZXhhbXBsZSB0YWcgPSBIdG1sVGFnLm5ldyggJ2RpdicsIHsgJ3dpZHRoJzogMTB9KVxuICAgKi9cblxuXG4gIGh0bWx0YWdfY3JlYXRlQ2xhc3MoSHRtbFRhZywgW3tcbiAgICBrZXk6IFwiaHRtbEF0dHJzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogY29tYmluZSBrZXkgYW5kIHZhbHVlIGZyb20gdGhlIGBhdHRyYCB0byBnZW5lcmF0ZSBhbiBIVE1MIHRhZyBhdHRyaWJ1dGVzIHN0cmluZy5cbiAgICAgKiBgVHJhbnNmb3JtYXRpb246OnRvSHRtbFRhZ09wdGlvbnNgIGlzIHVzZWQgdG8gZmlsdGVyIG91dCB0cmFuc2Zvcm1hdGlvbiBhbmQgY29uZmlndXJhdGlvbiBrZXlzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBhdHRyaWJ1dGVzIGluIHRoZSBmb3JtYXQgYCdrZXkxPVwidmFsdWUxXCIga2V5Mj1cInZhbHVlMlwiJ2BcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHRtbEF0dHJzKGF0dHJzKSB7XG4gICAgICB2YXIga2V5LCBwYWlycywgdmFsdWU7XG4gICAgICByZXR1cm4gcGFpcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICB2YWx1ZSA9IGVzY2FwZVF1b3RlcyhhdHRyc1trZXldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpLnNvcnQoKS5qb2luKCcgJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb3B0aW9ucyByZWxhdGVkIHRvIHRoaXMgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnRvT3B0aW9ucygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIG9wdGlvbiBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvblxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2F0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICAvLyBUaGUgYXR0cmlidXRlcyBhcmUgYmUgY29tcHV0ZWQgZnJvbSB0aGUgb3B0aW9ucyBldmVyeSB0aW1lIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAgICB2YXIgaHRtbEF0dHJpYnV0ZXMgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkudG9IdG1sQXR0cmlidXRlcygpO1xuICAgICAgT2JqZWN0LmtleXMoaHRtbEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGh0bWxBdHRyaWJ1dGVzW2tleV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGh0bWxBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcykge1xuICAgICAgICAvLyBDdXJyZW50bHkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkIGJvdGggYXQgdGhlIHRvcCBsZXZlbCBhbmQgdW5kZXIgJ2F0dHJpYnV0ZXMnXG4gICAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGh0bWxBdHRyaWJ1dGVzLCBodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZGVsZXRlIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodG1sQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgdGFnIGF0dHJpYnV0ZSBuYW1lZCBgbmFtZWAgdG8gYHZhbHVlYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3NldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc2V0KFwiaHRtbF9cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0YWcgYXR0cmlidXRlIGBuYW1lYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzKClbXCJodG1sX1wiLmNvbmNhdChuYW1lKV0gfHwgdGhpcy5hdHRyaWJ1dGVzKClbbmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgdGFnIGF0dHJpYnV0ZWQgbmFtZWQgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjcmVtb3ZlQXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5yZW1vdmUoXCJodG1sX1wiLmNvbmNhdChuYW1lKSkpICE9IG51bGwgPyByZWYgOiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjb250ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNvcGVuVGFnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlblRhZygpIHtcbiAgICAgIHZhciB0YWcgPSBcIjxcIiArIHRoaXMubmFtZTtcbiAgICAgIHZhciBodG1sQXR0cnMgPSB0aGlzLmh0bWxBdHRycyh0aGlzLmF0dHJpYnV0ZXMoKSk7XG5cbiAgICAgIGlmIChodG1sQXR0cnMgJiYgaHRtbEF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGFnICs9IFwiIFwiICsgaHRtbEF0dHJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFnICsgXCI+XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2Nsb3NlVGFnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiPC9cIi5jb25jYXQodGhpcy5uYW1lLCBcIj5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjdG9IdG1sXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBIVE1MIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0h0bWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVuVGFnKCkgKyB0aGlzLmNvbnRlbnQoKSArIHRoaXMuY2xvc2VUYWcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjdG9ET01cbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgdmFyIGVsZW1lbnQsIG5hbWUsIHJlZiwgdmFsdWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IFwiQ2FuJ3QgY3JlYXRlIERPTSBpZiBkb2N1bWVudCBpcyBub3QgcHJlc2VudCFcIjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lKTtcbiAgICAgIHJlZiA9IHRoaXMuYXR0cmlidXRlcygpO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1Jlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSB7XG4gICAgICB2YXIgZGF0YVNyYztcbiAgICAgIGRhdGFTcmMgPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMtY2FjaGUnKSB8fCBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMnKTtcbiAgICAgIHJldHVybiBsb2Rhc2hfaGFzQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpICYmIC9cXGJ3X2F1dG9cXGIvLmV4ZWMoZGF0YVNyYyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEh0bWxUYWc7XG59KCk7XG5cbjtcbi8qKlxuICogUmVwcmVzZW50IHRoZSBnaXZlbiBrZXkgYW5kIHZhbHVlIGFzIGFuIEhUTUwgYXR0cmlidXRlLlxuICogQGZ1bmN0aW9uIHRvQXR0cmlidXRlXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSB7Knxib29sZWFufSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYm9vbGVhbiBgdHJ1ZWAsIHJldHVybiB0aGUga2V5IG9ubHkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlXG4gKlxuICovXG5cbmZ1bmN0aW9uIGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBrZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIlwiKTtcbiAgfVxufVxuLyoqXG4gKiBJZiBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZywgcmVwbGFjZXMgcXVvdGVzIHdpdGggY2hhcmFjdGVyIGVudGl0aWVzICgmIzM0OywgJiMzOTspXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBjaGFuZ2VcbiAqIEByZXR1cm5zIHsqfSBjaGFuZ2VkIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXModmFsdWUpIHtcbiAgcmV0dXJuIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJ1wiJywgJyYjMzQ7JykucmVwbGFjZShcIidcIiwgJyYjMzk7JykgOiB2YWx1ZTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHRtbHRhZyA9IChodG1sdGFnX0h0bWxUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXJsLmpzXG52YXIgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJcIiwgXCJhY2Nlc3NpYmlsaXR5XCJdO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG4vKipcbiAqIEFkZHMgcHJvdG9jb2wsIGhvc3QsIHBhdGhuYW1lIHByZWZpeGVzIHRvIGdpdmVuIHN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVXJsKHN0cikge1xuICB2YXIgcHJlZml4ID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgZG9jdW1lbnQubG9jYXRpb24uaG9zdDtcblxuICBpZiAoc3RyWzBdID09PSAnPycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoc3RyWzBdICE9PSAnLycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCAnLycpO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeCArIHN0cjtcbn1cbi8qKlxuICogQ2hlY2sgaXMgZ2l2ZW4gc3RyaW5nIGlzIGEgdXJsXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVXJsKHN0cikge1xuICByZXR1cm4gc3RyID8gISFzdHIubWF0Y2goL15odHRwcz86XFwvLykgOiBmYWxzZTtcbn0gLy8gUHJvZHVjZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDUgdG8gYmUgdXNlZCBmb3IgY2RuIHN1YiBkb21haW5zIGRlc2lnbmF0aW9uXG5cblxuZnVuY3Rpb24gY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKSB7XG4gIHJldHVybiBzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDE7XG59XG4vKipcbiAqIFJlbW92ZXMgc2lnbmF0dXJlIGZyb20gb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgc2lnbmF0dXJlXG4gKiBNYWtlcyBzdXJlIHNpZ25hdHVyZSBpcyBlbXB0eSBvciBvZiB0aGlzIGZvcm1hdDogcy0tc2lnbmF0dXJlLS1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHNpZ25hdHVyZVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlU2lnbmF0dXJlKG9wdGlvbnMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IG9wdGlvbnMuc2lnbmF0dXJlO1xuICB2YXIgaXNGb3JtYXR0ZWQgPSAhc2lnbmF0dXJlIHx8IHNpZ25hdHVyZS5pbmRleE9mKCdzLS0nKSA9PT0gMCAmJiBzaWduYXR1cmUuc3Vic3RyKC0yKSA9PT0gJy0tJztcbiAgZGVsZXRlIG9wdGlvbnMuc2lnbmF0dXJlO1xuICByZXR1cm4gaXNGb3JtYXR0ZWQgPyBzaWduYXR1cmUgOiBcInMtLVwiLmNvbmNhdChzaWduYXR1cmUsIFwiLS1cIik7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgVVJMIHByZWZpeCBmb3IgQ2xvdWRpbmFyeSByZXNvdXJjZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgdGhlIHJlc291cmNlIHB1YmxpYyBJRFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbG91ZF9uYW1lIC0gdGhlIGNsb3VkIG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNkbl9zdWJkb21haW49ZmFsc2VdIC0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGJ1aWxkIFVSTHMgd2l0aFxuICogIG11bHRpcGxlIENETiBzdWItZG9tYWlucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcml2YXRlX2Nkbl0gLSBCb29sZWFuIChkZWZhdWx0OiBmYWxzZSkuIFNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzXG4gKiAgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3RvY29sPVwiaHR0cDovL1wiXSAtIHRoZSBVUkkgcHJvdG9jb2wgdG8gdXNlLiBJZiBvcHRpb25zLnNlY3VyZSBpcyB0cnVlLFxuICogIHRoZSB2YWx1ZSBpcyBvdmVycmlkZGVuIHRvIFwiaHR0cHM6Ly9cIlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb25dIC0gVGhlIGRvbWFpbiBuYW1lIG9mIHRoZSBDRE4gZGlzdHJpYnV0aW9uIHRvIHVzZSBmb3IgYnVpbGRpbmcgSFRUUFMgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNuYW1lXSAtIEN1c3RvbSBkb21haW4gbmFtZSB0byB1c2UgZm9yIGJ1aWxkaW5nIEhUVFAgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uIGFuZCBhIGN1c3RvbSBDTkFNRS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW49dHJ1ZV0gLSBXaGVuIG9wdGlvbnMuc2VjdXJlIGlzIHRydWUgYW5kIHRoaXMgcGFyYW1ldGVyIGlzIGZhbHNlLFxuICogIHRoZSBzdWJkb21haW4gaXMgc2V0IHRvIFwicmVzXCIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZT1mYWxzZV0gLSBGb3JjZSBIVFRQUyBVUkxzIG9mIGltYWdlcyBldmVuIGlmIGVtYmVkZGVkIGluIG5vbi1zZWN1cmUgSFRUUCBwYWdlcy5cbiAqICBXaGVuIHRoaXMgdmFsdWUgaXMgdHJ1ZSwgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uIHdpbGwgYmUgdXNlZCBhcyBob3N0IGlmIHByb3ZpZGVkLCBhbmQgb3B0aW9ucy5wcm90b2NvbCBpcyBzZXRcbiAqICB0byBcImh0dHBzOi8vXCIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgVVJMIHByZWZpeCBmb3IgdGhlIHJlc291cmNlLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeChwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jbG91ZF9uYW1lICYmIG9wdGlvbnMuY2xvdWRfbmFtZVswXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvcmVzJyArIG9wdGlvbnMuY2xvdWRfbmFtZTtcbiAgfSAvLyBkZWZhdWx0c1xuXG5cbiAgdmFyIHByb3RvY29sID0gXCJodHRwOi8vXCI7XG4gIHZhciBjZG5QYXJ0ID0gXCJcIjtcbiAgdmFyIHN1YmRvbWFpbiA9IFwicmVzXCI7XG4gIHZhciBob3N0ID0gXCIuY2xvdWRpbmFyeS5jb21cIjtcbiAgdmFyIHBhdGggPSBcIi9cIiArIG9wdGlvbnMuY2xvdWRfbmFtZTsgLy8gbW9kaWZpY2F0aW9uc1xuXG4gIGlmIChvcHRpb25zLnByb3RvY29sKSB7XG4gICAgcHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sICsgJy8vJztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByaXZhdGVfY2RuKSB7XG4gICAgY2RuUGFydCA9IG9wdGlvbnMuY2xvdWRfbmFtZSArIFwiLVwiO1xuICAgIHBhdGggPSBcIlwiO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2RuX3N1YmRvbWFpbikge1xuICAgIHN1YmRvbWFpbiA9IFwicmVzLVwiICsgY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNlY3VyZSkge1xuICAgIHByb3RvY29sID0gXCJodHRwczovL1wiO1xuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW4gPT09IGZhbHNlKSB7XG4gICAgICBzdWJkb21haW4gPSBcInJlc1wiO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT0gbnVsbCAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IE9MRF9BS0FNQUlfU0hBUkVEX0NETiAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IFNIQVJFRF9DRE4pIHtcbiAgICAgIGNkblBhcnQgPSBcIlwiO1xuICAgICAgc3ViZG9tYWluID0gXCJcIjtcbiAgICAgIGhvc3QgPSBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb247XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuY25hbWUpIHtcbiAgICBwcm90b2NvbCA9IFwiaHR0cDovL1wiO1xuICAgIGNkblBhcnQgPSBcIlwiO1xuICAgIHN1YmRvbWFpbiA9IG9wdGlvbnMuY2RuX3N1YmRvbWFpbiA/ICdhJyArIChzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDEpICsgJy4nIDogJyc7XG4gICAgaG9zdCA9IG9wdGlvbnMuY25hbWU7XG4gIH1cblxuICByZXR1cm4gW3Byb3RvY29sLCBjZG5QYXJ0LCBzdWJkb21haW4sIGhvc3QsIHBhdGhdLmpvaW4oXCJcIik7XG59XG4vKipcbiAqIFJldHVybiB0aGUgcmVzb3VyY2UgdHlwZSBhbmQgYWN0aW9uIHR5cGUgYmFzZWQgb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cbiAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2hhbmRsZVJlc291cmNlVHlwZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSByZXNvdXJjZV90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J3VwbG9hZCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VybF9zdWZmaXhdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2Vfcm9vdF9wYXRoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvcnRlbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJlc291cmNlX3R5cGUvdHlwZVxuICogQGlnbm9yZVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VUeXBlKF9yZWYpIHtcbiAgdmFyIF9yZWYkcmVzb3VyY2VfdHlwZSA9IF9yZWYucmVzb3VyY2VfdHlwZSxcbiAgICAgIHJlc291cmNlX3R5cGUgPSBfcmVmJHJlc291cmNlX3R5cGUgPT09IHZvaWQgMCA/IFwiaW1hZ2VcIiA6IF9yZWYkcmVzb3VyY2VfdHlwZSxcbiAgICAgIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/IFwidXBsb2FkXCIgOiBfcmVmJHR5cGUsXG4gICAgICB1cmxfc3VmZml4ID0gX3JlZi51cmxfc3VmZml4LFxuICAgICAgdXNlX3Jvb3RfcGF0aCA9IF9yZWYudXNlX3Jvb3RfcGF0aCxcbiAgICAgIHNob3J0ZW4gPSBfcmVmLnNob3J0ZW47XG4gIHZhciBvcHRpb25zLFxuICAgICAgcmVzb3VyY2VUeXBlID0gcmVzb3VyY2VfdHlwZTtcblxuICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHJlc291cmNlVHlwZSkpIHtcbiAgICBvcHRpb25zID0gcmVzb3VyY2VUeXBlO1xuICAgIHJlc291cmNlVHlwZSA9IG9wdGlvbnMucmVzb3VyY2VfdHlwZTtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHNob3J0ZW4gPSBvcHRpb25zLnNob3J0ZW47XG4gIH1cblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgdHlwZSA9ICd1cGxvYWQnO1xuICB9XG5cbiAgaWYgKHVybF9zdWZmaXggIT0gbnVsbCkge1xuICAgIHJlc291cmNlVHlwZSA9IFNFT19UWVBFU1tcIlwiLmNvbmNhdChyZXNvdXJjZVR5cGUsIFwiL1wiKS5jb25jYXQodHlwZSldO1xuICAgIHR5cGUgPSBudWxsO1xuXG4gICAgaWYgKHJlc291cmNlVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgU3VmZml4IG9ubHkgc3VwcG9ydGVkIGZvciBcIi5jb25jYXQoT2JqZWN0LmtleXMoU0VPX1RZUEVTKS5qb2luKCcsICcpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZV9yb290X3BhdGgpIHtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSAnaW1hZ2UnICYmIHR5cGUgPT09ICd1cGxvYWQnIHx8IHJlc291cmNlVHlwZSA9PT0gXCJpbWFnZXNcIikge1xuICAgICAgcmVzb3VyY2VUeXBlID0gbnVsbDtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IHBhdGggb25seSBzdXBwb3J0ZWQgZm9yIGltYWdlL3VwbG9hZFwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvcnRlbiAmJiByZXNvdXJjZVR5cGUgPT09ICdpbWFnZScgJiYgdHlwZSA9PT0gJ3VwbG9hZCcpIHtcbiAgICByZXNvdXJjZVR5cGUgPSAnaXUnO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFtyZXNvdXJjZVR5cGUsIHR5cGVdLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBFbmNvZGUgcHVibGljSWRcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHJldHVybnMge3N0cmluZ30gZW5jb2RlZCBwdWJsaWNJZFxuICovXG5cblxuZnVuY3Rpb24gZW5jb2RlUHVibGljSWQocHVibGljSWQpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCkucmVwbGFjZSgvJTNBL2csICc6JykucmVwbGFjZSgvJTJGL2csICcvJyk7XG59XG4vKipcbiAqIEVuY29kZSBhbmQgZm9ybWF0IHB1YmxpY0lkXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwdWJsaWNJZFxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0UHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzVXJsKHB1YmxpY0lkKSkge1xuICAgIHB1YmxpY0lkID0gZW5jb2RlUHVibGljSWQocHVibGljSWQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcHVibGljSWQgaXMgVVJJIGVuY29kZWQuXG4gICAgICBwdWJsaWNJZCA9IGRlY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICBwdWJsaWNJZCA9IGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKTtcblxuICAgIGlmIChvcHRpb25zLnVybF9zdWZmaXgpIHtcbiAgICAgIHB1YmxpY0lkID0gcHVibGljSWQgKyAnLycgKyBvcHRpb25zLnVybF9zdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMudHJ1c3RfcHVibGljX2lkKSB7XG4gICAgICAgIHB1YmxpY0lkID0gcHVibGljSWQucmVwbGFjZSgvXFwuKGpwZ3xwbmd8Z2lmfHdlYnApJC8sICcnKTtcbiAgICAgIH1cblxuICAgICAgcHVibGljSWQgPSBwdWJsaWNJZCArICcuJyArIG9wdGlvbnMuZm9ybWF0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdWJsaWNJZDtcbn1cbi8qKlxuICogR2V0IGFueSBlcnJvciB3aXRoIHVybCBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gaWYgZXJyb3IsIG90aGVyd2lzZSByZXR1cm4gdW5kZWZpbmVkXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gIHZhciBjbG91ZF9uYW1lID0gb3B0aW9ucy5jbG91ZF9uYW1lLFxuICAgICAgdXJsX3N1ZmZpeCA9IG9wdGlvbnMudXJsX3N1ZmZpeDtcblxuICBpZiAoIWNsb3VkX25hbWUpIHtcbiAgICByZXR1cm4gJ1Vua25vd24gY2xvdWRfbmFtZSc7XG4gIH1cblxuICBpZiAodXJsX3N1ZmZpeCAmJiB1cmxfc3VmZml4Lm1hdGNoKC9bXFwuXFwvXS8pKSB7XG4gICAgcmV0dXJuICd1cmxfc3VmZml4IHNob3VsZCBub3QgaW5jbHVkZSAuIG9yIC8nO1xuICB9XG59XG4vKipcbiAqIEdldCB2ZXJzaW9uIHBhcnQgb2YgdGhlIHVybFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVZlcnNpb24ocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgLy8gZm9yY2VfdmVyc2lvbiBwYXJhbSBtZWFucyB0byBtYWtlIHN1cmUgdGhlcmUgaXMgYSB2ZXJzaW9uIGluIHRoZSB1cmwgKERlZmF1bHQgaXMgdHJ1ZSlcbiAgdmFyIGlzRm9yY2VWZXJzaW9uID0gb3B0aW9ucy5mb3JjZV92ZXJzaW9uIHx8IHR5cGVvZiBvcHRpb25zLmZvcmNlX3ZlcnNpb24gPT09ICd1bmRlZmluZWQnOyAvLyBJcyB2ZXJzaW9uIGluY2x1ZGVkIGluIHB1YmxpY0lkIG9yIGluIG9wdGlvbnMsIG9yIHB1YmxpY0lkIGlzIGEgdXJsIChkb2Vzbid0IG5lZWQgdmVyc2lvbilcblxuICB2YXIgaXNWZXJzaW9uRXhpc3QgPSBwdWJsaWNJZC5pbmRleE9mKCcvJykgPCAwIHx8IHB1YmxpY0lkLm1hdGNoKC9edlswLTldKy8pIHx8IGlzVXJsKHB1YmxpY0lkKSB8fCBvcHRpb25zLnZlcnNpb247XG5cbiAgaWYgKGlzRm9yY2VWZXJzaW9uICYmICFpc1ZlcnNpb25FeGlzdCkge1xuICAgIG9wdGlvbnMudmVyc2lvbiA9IDE7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy52ZXJzaW9uID8gXCJ2XCIuY29uY2F0KG9wdGlvbnMudmVyc2lvbikgOiAnJztcbn1cbi8qKlxuICogR2V0IGZpbmFsIHRyYW5zZm9ybWF0aW9uIGNvbXBvbmVudCBmb3IgdXJsIHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVUcmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gIHZhciBfcmVmMiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBwbGFjZWhvbGRlciA9IF9yZWYyLnBsYWNlaG9sZGVyLFxuICAgICAgYWNjZXNzaWJpbGl0eSA9IF9yZWYyLmFjY2Vzc2liaWxpdHksXG4gICAgICBvdGhlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIF9leGNsdWRlZCk7XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3RoZXJPcHRpb25zKTsgLy8gQXBwZW5kIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG5cbiAgaWYgKGFjY2Vzc2liaWxpdHkgJiYgQUNDRVNTSUJJTElUWV9NT0RFU1thY2Nlc3NpYmlsaXR5XSkge1xuICAgIHJlc3VsdC5jaGFpbigpLmVmZmVjdChBQ0NFU1NJQklMSVRZX01PREVTW2FjY2Vzc2liaWxpdHldKTtcbiAgfSAvLyBBcHBlbmQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG5cblxuICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwicHJlZG9taW5hbnQtY29sb3JcIiAmJiByZXN1bHQuZ2V0VmFsdWUoJ3dpZHRoJykgJiYgcmVzdWx0LmdldFZhbHVlKCdoZWlnaHQnKSkge1xuICAgICAgcGxhY2Vob2xkZXIgKz0gJy1waXhlbCc7XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zID0gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNbcGxhY2Vob2xkZXJdIHx8IFBMQUNFSE9MREVSX0lNQUdFX01PREVTLmJsdXI7XG4gICAgcGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jaGFpbigpLnRyYW5zZm9ybWF0aW9uKHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zZXJpYWxpemUoKTtcbn1cbi8qKlxuICogSWYgdHlwZSBpcyAnZmV0Y2gnLCB1cGRhdGUgcHVibGljSWQgdG8gYmUgYSB1cmxcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlUHVibGljSWQocHVibGljSWQsIF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZTtcbiAgcmV0dXJuICFpc1VybChwdWJsaWNJZCkgJiYgdHlwZSA9PT0gJ2ZldGNoJyA/IG1ha2VVcmwocHVibGljSWQpIDogcHVibGljSWQ7XG59XG4vKipcbiAqIEdlbmVyYXRlIHVybCBzdHJpbmdcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGZpbmFsIHVybFxuICovXG5cblxuZnVuY3Rpb24gdXJsU3RyaW5nKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChwdWJsaWNJZCkgJiYgKG9wdGlvbnMudHlwZSA9PT0gJ3VwbG9hZCcgfHwgb3B0aW9ucy50eXBlID09PSAnYXNzZXQnKSkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gaGFuZGxlVmVyc2lvbihwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGhhbmRsZVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICB2YXIgcHJlZml4ID0gaGFuZGxlUHJlZml4KHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIHNpZ25hdHVyZSA9IGhhbmRsZVNpZ25hdHVyZShvcHRpb25zKTtcbiAgdmFyIHJlc291cmNlVHlwZSA9IGhhbmRsZVJlc291cmNlVHlwZShvcHRpb25zKTtcbiAgcHVibGljSWQgPSBmb3JtYXRQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoW3ByZWZpeCwgcmVzb3VyY2VUeXBlLCBzaWduYXR1cmUsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB2ZXJzaW9uLCBwdWJsaWNJZF0pLmpvaW4oJy8nKS5yZXBsYWNlKC8oW146XSlcXC8rL2csICckMS8nKSAvLyByZXBsYWNlICcvLy8nIHdpdGggJy8vJ1xuICAucmVwbGFjZSgnICcsICclMjAnKTtcbn1cbi8qKlxuICogTWVyZ2Ugb3B0aW9ucyBhbmQgY29uZmlnIHdpdGggZGVmYXVsdHNcbiAqIHVwZGF0ZSBvcHRpb25zIGZldGNoX2Zvcm1hdCBhY2NvcmRpbmcgdG8gJ3R5cGUnIHBhcmFtXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGNvbmZpZ1xuICogQHJldHVybnMgeyp9IHVwZGF0ZWQgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgY29uZmlnKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2Ygc3JjX3RyYW5zZm9ybWF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMudG9PcHRpb25zKCk7XG4gIH1cblxuICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIGNvbmZpZywgREVGQVVMVF9JTUFHRV9QQVJBTVMpO1xuXG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdmZXRjaCcpIHtcbiAgICBvcHRpb25zLmZldGNoX2Zvcm1hdCA9IG9wdGlvbnMuZmV0Y2hfZm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0O1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAqIEBmdW5jdGlvbiB1cmxcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIG1lZGlhIGFzc2V0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICogQHBhcmFtIHtvYmplY3R9IFtjb25maWc9e31dIC0gVVJMIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJlc291cmNlX3R5cGU9J2ltYWdlJ10gLSBUaGUgdHlwZSBvZiBhc3NldC4gPHA+UG9zc2libGUgdmFsdWVzOjxici8+XG4gKiAgLSBgaW1hZ2VgPGJyLz5cbiAqICAtIGB2aWRlb2A8YnIvPlxuICogIC0gYHJhd2BcbiAqIEBwYXJhbSB7c2lnbmF0dXJlfSBbb3B0aW9ucy5zaWduYXR1cmU9J3MtLTEyMzQ1Njc4LS0nXSAtIFRoZSBzaWduYXR1cmUgY29tcG9uZW50IG9mIGFcbiAqICBzaWduZWQgZGVsaXZlcnkgVVJMIG9mIHRoZSBmb3JtYXQ6IC9zLS1TSUdOQVRVUkUtLS8uXG4gKiAgRm9yIGRldGFpbHMgb24gc2lnbmF0dXJlcywgc2VlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NpZ25hdHVyZXNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5TaWduYXR1cmVzPC9hPi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lZGlhIGFzc2V0IFVSTC5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gKi9cblxuXG5mdW5jdGlvbiB1cmxfdXJsKHB1YmxpY0lkKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgaWYgKCFwdWJsaWNJZCkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBjb25maWcpO1xuICBwdWJsaWNJZCA9IHByZXBhcmVQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciBlcnJvciA9IHZhbGlkYXRlKG9wdGlvbnMpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHJlc3VsdFVybCA9IHVybFN0cmluZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSBnZXRBbmFseXRpY3NPcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBzZGtBbmFseXRpY3NTaWduYXR1cmUgPSBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoYW5hbHl0aWNzT3B0aW9ucyk7IC8vIHVybCBtaWdodCBhbHJlYWR5IGhhdmUgYSAnPycgcXVlcnkgcGFyYW1cblxuICAgIHZhciBhcHBlbmRlciA9ICc/JztcblxuICAgIGlmIChyZXN1bHRVcmwuaW5kZXhPZignPycpID49IDApIHtcbiAgICAgIGFwcGVuZGVyID0gJyYnO1xuICAgIH1cblxuICAgIHJlc3VsdFVybCA9IFwiXCIuY29uY2F0KHJlc3VsdFVybCkuY29uY2F0KGFwcGVuZGVyLCBcIl9hPVwiKS5jb25jYXQoc2RrQW5hbHl0aWNzU2lnbmF0dXJlKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dGhfdG9rZW4pIHtcbiAgICB2YXIgX2FwcGVuZGVyID0gcmVzdWx0VXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuXG4gICAgcmVzdWx0VXJsID0gXCJcIi5jb25jYXQocmVzdWx0VXJsKS5jb25jYXQoX2FwcGVuZGVyLCBcIl9fY2xkX3Rva2VuX189XCIpLmNvbmNhdChvcHRpb25zLmF1dGhfdG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFVybDtcbn1cbjtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZ2VuZXJhdGVCcmVha3BvaW50cy5qc1xuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyhhcnIpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2V0cyBvciBwb3B1bGF0ZXMgc3Jjc2V0IGJyZWFrcG9pbnRzIHVzaW5nIHByb3ZpZGVkIHBhcmFtZXRlcnNcbiAqIEVpdGhlciB0aGUgYnJlYWtwb2ludHMgb3IgbWluX3dpZHRoLCBtYXhfd2lkdGgsIG1heF9pbWFnZXMgbXVzdCBiZSBwcm92aWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzcmNzZXR9IHNyY3NldCBPcHRpb25zIHdpdGggZWl0aGVyIGBicmVha3BvaW50c2Agb3IgYG1pbl93aWR0aGAsIGBtYXhfd2lkdGhgLCBhbmQgYG1heF9pbWFnZXNgXG4gKlxuICogQHJldHVybiB7bnVtYmVyW119IEFycmF5IG9mIGJyZWFrcG9pbnRzXG4gKlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzKHNyY3NldCkge1xuICB2YXIgYnJlYWtwb2ludHMgPSBzcmNzZXQuYnJlYWtwb2ludHMgfHwgW107XG5cbiAgaWYgKGJyZWFrcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBicmVha3BvaW50cztcbiAgfVxuXG4gIHZhciBfbWFwID0gW3NyY3NldC5taW5fd2lkdGgsIHNyY3NldC5tYXhfd2lkdGgsIHNyY3NldC5tYXhfaW1hZ2VzXS5tYXAoTnVtYmVyKSxcbiAgICAgIF9tYXAyID0gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KF9tYXAsIDMpLFxuICAgICAgbWluX3dpZHRoID0gX21hcDJbMF0sXG4gICAgICBtYXhfd2lkdGggPSBfbWFwMlsxXSxcbiAgICAgIG1heF9pbWFnZXMgPSBfbWFwMlsyXTtcblxuICBpZiAoW21pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzXS5zb21lKGlzTmFOKSkge1xuICAgIHRocm93ICdFaXRoZXIgKG1pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzKSAnICsgJ29yIGJyZWFrcG9pbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gdGhlIGltYWdlIHNyY3NldCBhdHRyaWJ1dGUnO1xuICB9XG5cbiAgaWYgKG1pbl93aWR0aCA+IG1heF93aWR0aCkge1xuICAgIHRocm93ICdtaW5fd2lkdGggbXVzdCBiZSBsZXNzIHRoYW4gbWF4X3dpZHRoJztcbiAgfVxuXG4gIGlmIChtYXhfaW1hZ2VzIDw9IDApIHtcbiAgICB0aHJvdyAnbWF4X2ltYWdlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcic7XG4gIH0gZWxzZSBpZiAobWF4X2ltYWdlcyA9PT0gMSkge1xuICAgIG1pbl93aWR0aCA9IG1heF93aWR0aDtcbiAgfVxuXG4gIHZhciBzdGVwU2l6ZSA9IE1hdGguY2VpbCgobWF4X3dpZHRoIC0gbWluX3dpZHRoKSAvIE1hdGgubWF4KG1heF9pbWFnZXMgLSAxLCAxKSk7XG5cbiAgZm9yICh2YXIgY3VycmVudCA9IG1pbl93aWR0aDsgY3VycmVudCA8IG1heF93aWR0aDsgY3VycmVudCArPSBzdGVwU2l6ZSkge1xuICAgIGJyZWFrcG9pbnRzLnB1c2goY3VycmVudCk7XG4gIH1cblxuICBicmVha3BvaW50cy5wdXNoKG1heF93aWR0aCk7XG4gIHJldHVybiBicmVha3BvaW50cztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvc3Jjc2V0VXRpbHMuanNcblxudmFyIHNyY3NldFV0aWxzX2lzRW1wdHkgPSBpc0VtcHR5O1xuXG5cblxuLyoqXG4gKiBPcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHNyY3NldCBhdHRyaWJ1dGUuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBzcmNzZXRcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcltdfHN0cmluZ1tdKX0gICBbYnJlYWtwb2ludHNdIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttaW5fd2lkdGhdICAgTWluaW1hbCB3aWR0aCBvZiB0aGUgc3Jjc2V0IGltYWdlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWF4X3dpZHRoXSAgIE1heGltYWwgd2lkdGggb2YgdGhlIHNyY3NldCBpbWFnZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21heF9pbWFnZXNdICBOdW1iZXIgb2Ygc3Jjc2V0IGltYWdlcyB0byBnZW5lcmF0ZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fHN0cmluZ30gICAgICAgICBbdHJhbnNmb3JtYXRpb25dIFRoZSB0cmFuc2Zvcm1hdGlvbiB0byB1c2UgaW4gdGhlIHNyY3NldCB1cmxzLlxuICogQHByb3BlcnR5IHtib29sZWFufSAgICAgICAgICAgICAgIFtzaXplc10gV2hldGhlciB0byBjYWxjdWxhdGUgYW5kIGFkZCB0aGUgc2l6ZXMgYXR0cmlidXRlLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgYSBzaW5nbGUgc3Jjc2V0IGl0ZW0gdXJsXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWQgIFB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggICAgICBXaWR0aCBpbiBwaXhlbHMgb2YgdGhlIHNyY3NldCBpdGVtLlxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgQWRkaXRpb25hbCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIFVSTCBvZiB0aGUgaXRlbVxuICovXG5cbmZ1bmN0aW9uIHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBjb25maWdQYXJhbXMgPSBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpO1xuICB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIHx8IG9wdGlvbnM7XG4gIGNvbmZpZ1BhcmFtcy5yYXdfdHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKFttZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYSh7fSwgdHJhbnNmb3JtYXRpb24pLCB7XG4gICAgY3JvcDogJ3NjYWxlJyxcbiAgICB3aWR0aDogd2lkdGhcbiAgfV0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiB1cmxfdXJsKHB1YmxpY19pZCwgY29uZmlnUGFyYW1zKTtcbn1cbi8qKlxuICogSWYgY2FjaGUgaXMgZW5hYmxlZCwgZ2V0IHRoZSBicmVha3BvaW50cyBmcm9tIHRoZSBjYWNoZS4gSWYgdGhlIHZhbHVlcyB3ZXJlIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUsXG4gKiBvciBjYWNoZSBpcyBub3QgZW5hYmxlZCwgZ2VuZXJhdGUgdGhlIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3Jjc2V0fSBzcmNzZXQgVGhlIHNyY3NldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfEFycmF5fVxuICovXG5cbmZ1bmN0aW9uIGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNfaWQpIHtcbiAgdmFyIHNyY3NldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc3Jjc2V0IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgSFRNTCBpbWcgdGFnXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWQgIFB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJyZWFrcG9pbnRzIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzIChpbiBwaXhlbHMpXG4gKiBAcGFyYW0ge29iamVjdH0gdHJhbnNmb3JtYXRpb24gVGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBJbmNsdWRlcyBodG1sIHRhZyBvcHRpb25zLCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBzcmNzZXQgYXR0cmlidXRlIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUocHVibGljX2lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0LmEob3B0aW9ucyk7XG4gIHBhdGNoRmV0Y2hGb3JtYXQob3B0aW9ucyk7XG4gIHJldHVybiBicmVha3BvaW50cy5tYXAoZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucyksIFwiIFwiKS5jb25jYXQod2lkdGgsIFwid1wiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc2l6ZXMgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBIVE1MIGltZyB0YWdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcltdfSBicmVha3BvaW50cyBBbiBhcnJheSBvZiBicmVha3BvaW50cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIHNpemVzIGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpIHtcbiAgaWYgKGJyZWFrcG9pbnRzID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gYnJlYWtwb2ludHMubWFwKGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdCh3aWR0aCwgXCJweCkgXCIpLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc3Jjc2V0IGFuZCBzaXplcyBhdHRyaWJ1dGVzIG9mIHRoZSBpbWFnZSB0YWdcbiAqXG4gKiBHZW5lcmF0ZWQgYXR0cmlidXRlcyBhcmUgYWRkZWQgdG8gYXR0cmlidXRlcyBhcmd1bWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgcHVibGljSWQgIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gICAgYXR0cmlidXRlcyBFeGlzdGluZyBIVE1MIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gICAgc3Jjc2V0RGF0YVxuICogQHBhcmFtIHtvYmplY3R9ICAgIG9wdGlvbnMgICAgQWRkaXRpb25hbCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gYXJyYXkgVGhlIHJlc3BvbnNpdmUgYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyhwdWJsaWNJZCkge1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBzcmNzZXREYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAvLyBDcmVhdGUgYm90aCBzcmNzZXQgYW5kIHNpemVzIGhlcmUgdG8gYXZvaWQgZmV0Y2hpbmcgYnJlYWtwb2ludHMgdHdpY2VcbiAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG5cbiAgaWYgKHNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0RGF0YSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG4gIH1cblxuICB2YXIgZ2VuZXJhdGVTaXplcyA9ICFhdHRyaWJ1dGVzLnNpemVzICYmIHNyY3NldERhdGEuc2l6ZXMgPT09IHRydWU7XG4gIHZhciBnZW5lcmF0ZVNyY3NldCA9ICFhdHRyaWJ1dGVzLnNyY3NldDtcblxuICBpZiAoZ2VuZXJhdGVTcmNzZXQgfHwgZ2VuZXJhdGVTaXplcykge1xuICAgIHZhciBicmVha3BvaW50cyA9IGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNJZCwgc3Jjc2V0RGF0YSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ2VuZXJhdGVTcmNzZXQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IHNyY3NldERhdGEudHJhbnNmb3JtYXRpb247XG4gICAgICB2YXIgc3Jjc2V0QXR0ciA9IGdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlKHB1YmxpY0lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0QXR0cikpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc3Jjc2V0ID0gc3Jjc2V0QXR0cjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2VuZXJhdGVTaXplcykge1xuICAgICAgdmFyIHNpemVzQXR0ciA9IGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpO1xuXG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc2l6ZXNBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zaXplcyA9IHNpemVzQXR0cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgbWVkaWEgcXVlcnlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWluX3dpZHRoXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWF4X3dpZHRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgbWVkaWEgcXVlcnkgc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVNZWRpYUF0dHIob3B0aW9ucykge1xuICB2YXIgbWVkaWFRdWVyeSA9IFtdO1xuXG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5taW5fd2lkdGggIT0gbnVsbCkge1xuICAgICAgbWVkaWFRdWVyeS5wdXNoKFwiKG1pbi13aWR0aDogXCIuY29uY2F0KG9wdGlvbnMubWluX3dpZHRoLCBcInB4KVwiKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4X3dpZHRoICE9IG51bGwpIHtcbiAgICAgIG1lZGlhUXVlcnkucHVzaChcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChvcHRpb25zLm1heF93aWR0aCwgXCJweClcIikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRpYVF1ZXJ5LmpvaW4oJyBhbmQgJyk7XG59XG52YXIgc3Jjc2V0VXJsID0gc2NhbGVkVXJsO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9pbWFnZXRhZy5qc1xuZnVuY3Rpb24gaW1hZ2V0YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBpbWFnZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBpbWFnZXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBpbWFnZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IGltYWdldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBpbWFnZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBpbWFnZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoaW1hZ2V0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IGltYWdldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBJbWFnZVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgaW1hZ2V0YWdfSW1hZ2VUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGltYWdldGFnX2luaGVyaXRzKEltYWdlVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IGltYWdldGFnX2NyZWF0ZVN1cGVyKEltYWdlVGFnKTtcblxuICBmdW5jdGlvbiBJbWFnZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGltYWdldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlVGFnKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImltZ1wiLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoSW1hZ2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyLCBvcHRpb25zLCBzcmNBdHRyaWJ1dGU7XG4gICAgICBhdHRyID0gaW1hZ2V0YWdfZ2V0KGltYWdldGFnX2dldFByb3RvdHlwZU9mKEltYWdlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmdldE9wdGlvbignYXR0cmlidXRlcycpIHx8IHt9O1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpIHx8IGF0dHJpYnV0ZXMuc3Jjc2V0O1xuICAgICAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG5cbiAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShzcmNzZXRQYXJhbSkpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc3Jjc2V0ID0gc3Jjc2V0UGFyYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyaWJ1dGVzLCBzcmNzZXRQYXJhbSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eShyZXNwb25zaXZlQXR0cmlidXRlcykpIHtcbiAgICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICAgIGRlbGV0ZSBhdHRyLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMpO1xuICAgICAgc3JjQXR0cmlidXRlID0gb3B0aW9ucy5yZXNwb25zaXZlICYmICFvcHRpb25zLmNsaWVudF9oaW50cyA/ICdkYXRhLXNyYycgOiAnc3JjJztcblxuICAgICAgaWYgKGF0dHJbc3JjQXR0cmlidXRlXSA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJbc3JjQXR0cmlidXRlXSA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbWFnZXRhZyA9IChpbWFnZXRhZ19JbWFnZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3NvdXJjZXRhZy5qc1xuZnVuY3Rpb24gc291cmNldGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc291cmNldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHNvdXJjZXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBzb3VyY2V0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBzb3VyY2V0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBzb3VyY2V0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgc291cmNldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gc291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChzb3VyY2V0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBTb3VyY2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cblxudmFyIHNvdXJjZXRhZ19Tb3VyY2VUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIHNvdXJjZXRhZ19pbmhlcml0cyhTb3VyY2VUYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gc291cmNldGFnX2NyZWF0ZVN1cGVyKFNvdXJjZVRhZyk7XG5cbiAgZnVuY3Rpb24gU291cmNlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgc291cmNldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZVRhZyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJzb3VyY2VcIiwgcHVibGljSWQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhTb3VyY2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBzcmNzZXRQYXJhbSA9IHRoaXMuZ2V0T3B0aW9uKCdzcmNzZXQnKTtcbiAgICAgIHZhciBhdHRyID0gc291cmNldGFnX2dldChzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YoU291cmNlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGF0dHIsIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyLCBzcmNzZXRQYXJhbSwgb3B0aW9ucykpO1xuXG4gICAgICBpZiAoIWF0dHIuc3Jjc2V0KSB7XG4gICAgICAgIGF0dHIuc3Jjc2V0ID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdHRyLm1lZGlhICYmIG9wdGlvbnMubWVkaWEpIHtcbiAgICAgICAgYXR0ci5tZWRpYSA9IGdlbmVyYXRlTWVkaWFBdHRyKG9wdGlvbnMubWVkaWEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU291cmNlVGFnO1xufShodG1sdGFnKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc291cmNldGFnID0gKHNvdXJjZXRhZ19Tb3VyY2VUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9waWN0dXJldGFnLmpzXG5mdW5jdGlvbiBwaWN0dXJldGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGljdHVyZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBwaWN0dXJldGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHBpY3R1cmV0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBwaWN0dXJldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHBpY3R1cmV0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAocGljdHVyZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5cbnZhciBwaWN0dXJldGFnX1BpY3R1cmVUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIHBpY3R1cmV0YWdfaW5oZXJpdHMoUGljdHVyZVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBwaWN0dXJldGFnX2NyZWF0ZVN1cGVyKFBpY3R1cmVUYWcpO1xuXG4gIGZ1bmN0aW9uIFBpY3R1cmVUYWcocHVibGljSWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHNvdXJjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXG4gICAgcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWN0dXJlVGFnKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ3BpY3R1cmUnLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgX3RoaXMud2lkdGhMaXN0ID0gc291cmNlcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgcGljdHVyZXRhZ19jcmVhdGVDbGFzcyhQaWN0dXJlVGFnLCBbe1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMud2lkdGhMaXN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbWluX3dpZHRoID0gX3JlZi5taW5fd2lkdGgsXG4gICAgICAgICAgICBtYXhfd2lkdGggPSBfcmVmLm1heF93aWR0aCxcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uID0gX3JlZi50cmFuc2Zvcm1hdGlvbjtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzMi5nZXRPcHRpb25zKCk7XG5cbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICAgICAgc291cmNlVHJhbnNmb3JtYXRpb24uY2hhaW4oKS5mcm9tT3B0aW9ucyh0eXBlb2YgdHJhbnNmb3JtYXRpb24gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgIHJhd190cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb25cbiAgICAgICAgfSA6IHRyYW5zZm9ybWF0aW9uKTtcbiAgICAgICAgb3B0aW9ucyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSB7XG4gICAgICAgICAgbWluX3dpZHRoOiBtaW5fd2lkdGgsXG4gICAgICAgICAgbWF4X3dpZHRoOiBtYXhfd2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiA9IHNvdXJjZVRyYW5zZm9ybWF0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZXRhZyhfdGhpczIucHVibGljSWQsIG9wdGlvbnMpLnRvSHRtbCgpO1xuICAgICAgfSkuam9pbignJykgKyBuZXcgaW1hZ2V0YWcodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpLnRvSHRtbCgpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgYXR0ciA9IHBpY3R1cmV0YWdfZ2V0KHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YoUGljdHVyZVRhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiICsgdGhpcy5uYW1lICsgXCI+XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBpY3R1cmVUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwaWN0dXJldGFnID0gKHBpY3R1cmV0YWdfUGljdHVyZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3ZpZGVvdGFnLmpzXG5mdW5jdGlvbiB2aWRlb3RhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHZpZGVvdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHZpZGVvdGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHZpZGVvdGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgdmlkZW90YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHZpZGVvdGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHZpZGVvdGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHZpZGVvdGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHZpZGVvdGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gdmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiB2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh2aWRlb3RhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG8pIHsgdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogVmlkZW8gVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAndXRpbCcsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cbnZhciBWSURFT19UQUdfUEFSQU1TID0gWydzb3VyY2VfdHlwZXMnLCAnc291cmNlX3RyYW5zZm9ybWF0aW9uJywgJ2ZhbGxiYWNrX2NvbnRlbnQnLCAncG9zdGVyJywgJ3NvdXJjZXMnXTtcbnZhciB2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyA9IFsnd2VibScsICdtcDQnLCAnb2d2J107XG52YXIgdmlkZW90YWdfREVGQVVMVF9QT1NURVJfT1BUSU9OUyA9IHtcbiAgZm9ybWF0OiAnanBnJyxcbiAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIFZpZGVvIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgVmlkZW9UYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cblxudmFyIHZpZGVvdGFnX1ZpZGVvVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICB2aWRlb3RhZ19pbmhlcml0cyhWaWRlb1RhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSB2aWRlb3RhZ19jcmVhdGVTdXBlcihWaWRlb1RhZyk7XG5cbiAgZnVuY3Rpb24gVmlkZW9UYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2aWRlb3RhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RhZyk7XG5cbiAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIERFRkFVTFRfVklERU9fUEFSQU1TKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ2aWRlb1wiLCBwdWJsaWNJZC5yZXBsYWNlKC9cXC4obXA0fG9ndnx3ZWJtKSQvLCAnJyksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IG9uIGVhY2ggc291cmNlXG4gICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggcGFpcnMgb2Ygc291cmNlIHR5cGUgYW5kIHNvdXJjZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAqL1xuXG5cbiAgdmlkZW90YWdfY3JlYXRlQ2xhc3MoVmlkZW9UYWcsIFt7XG4gICAga2V5OiBcInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc291cmNlIHR5cGVzIHRvIGluY2x1ZGUgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUeXBlc1xuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYW4gYXJyYXkgb2Ygc291cmNlIHR5cGVzXG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUeXBlcyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3N0ZXIgdG8gYmUgdXNlZCBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFBvc3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICAgKiAtIHN0cmluZzogYSBVUkwgdG8gdXNlIGZvciB0aGUgcG9zdGVyXG4gICAgICogLSBPYmplY3Q6IHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gdGhlIHBvc3Rlci4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhIHB1YmxpY19pZCB0byB1c2UgaW5zdGVhZCBvZiB0aGUgdmlkZW8gcHVibGljX2lkLlxuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3N0ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5wb3N0ZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCB0byB1c2UgYXMgZmFsbGJhY2sgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRGYWxsYmFja0NvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgY29udGVudCB0byB1c2UsIGluIEhUTUwgZm9ybWF0XG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLmZhbGxiYWNrQ29udGVudCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdzb3VyY2VfdHlwZXMnKTtcbiAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm1hdGlvbiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3RyYW5zZm9ybWF0aW9uJyk7XG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ2ZhbGxiYWNrX2NvbnRlbnQnKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTtcbiAgICAgIHZhciBpbm5lclRhZ3MgPSBbXTtcblxuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShzb3VyY2VzKSAmJiAhaXNFbXB0eShzb3VyY2VzKSkge1xuICAgICAgICBpbm5lclRhZ3MgPSBzb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgdmFyIHNyYyA9IHVybF91cmwoX3RoaXMucHVibGljSWQsIGRlZmF1bHRzKHt9LCBzb3VyY2UudHJhbnNmb3JtYXRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgZm9ybWF0OiBzb3VyY2UudHlwZVxuICAgICAgICAgIH0pLCBfdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2UudHlwZSwgc291cmNlLmNvZGVjcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgc291cmNlVHlwZXMgPSB2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgaW5uZXJUYWdzID0gc291cmNlVHlwZXMubWFwKGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZVRyYW5zZm9ybWF0aW9uW3NyY1R5cGVdIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICAgIGZvcm1hdDogc3JjVHlwZVxuICAgICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc3JjVHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlubmVyVGFncy5qb2luKCcnKSArIGZhbGxiYWNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgc291cmNlVHlwZXMgPSB0aGlzLmdldE9wdGlvbignc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgcG9zdGVyID0gdGhpcy5nZXRPcHRpb24oJ3Bvc3RlcicpO1xuXG4gICAgICBpZiAocG9zdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zdGVyID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocG9zdGVyKSkge1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBwb3N0ZXIucHVibGljX2lkICE9IG51bGwgPyBERUZBVUxUX0lNQUdFX1BBUkFNUyA6IHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlM7XG4gICAgICAgIHBvc3RlciA9IHVybF91cmwocG9zdGVyLnB1YmxpY19pZCB8fCB0aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgcG9zdGVyLCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHIgPSB2aWRlb3RhZ19nZXQodmlkZW90YWdfZ2V0UHJvdG90eXBlT2YoVmlkZW9UYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICBhdHRyID0gb21pdChhdHRyLCBWSURFT19UQUdfUEFSQU1TKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTsgLy8gSW4gY2FzZSBvZiBlbXB0eSBzb3VyY2VUeXBlcyAtIGZhbGxiYWNrIHRvIGRlZmF1bHQgc291cmNlIHR5cGVzIGlzIHVzZWQuXG5cbiAgICAgIHZhciBoYXNTb3VyY2VUYWdzID0gIWlzRW1wdHkoc291cmNlcykgfHwgaXNFbXB0eShzb3VyY2VUeXBlcykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZVR5cGVzKTtcblxuICAgICAgaWYgKCFoYXNTb3VyY2VUYWdzKSB7XG4gICAgICAgIGF0dHJbXCJzcmNcIl0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpLCB7XG4gICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBmb3JtYXQ6IHNvdXJjZVR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zdGVyICE9IG51bGwpIHtcbiAgICAgICAgYXR0cltcInBvc3RlclwiXSA9IHBvc3RlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY29kZWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbWVUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKCFpc0VtcHR5KHNvdXJjZVR5cGUpKSB7XG4gICAgICAgIHZhciB2aWRlb1R5cGUgPSBzb3VyY2VUeXBlID09PSAnb2d2JyA/ICdvZ2cnIDogc291cmNlVHlwZTtcbiAgICAgICAgbWltZVR5cGUgPSAndmlkZW8vJyArIHZpZGVvVHlwZTtcblxuICAgICAgICBpZiAoIWlzRW1wdHkoY29kZWNzKSkge1xuICAgICAgICAgIHZhciBjb2RlY3NTdHIgPSBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoY29kZWNzKSA/IGNvZGVjcy5qb2luKCcsICcpIDogY29kZWNzO1xuICAgICAgICAgIG1pbWVUeXBlICs9ICc7IGNvZGVjcz0nICsgY29kZWNzU3RyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIjxzb3VyY2UgXCIgKyB0aGlzLmh0bWxBdHRycyh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgfSkgKyBcIj5cIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlkZW9UYWc7XG59KGh0bWx0YWcpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2aWRlb3RhZyA9ICh2aWRlb3RhZ19WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2NsaWVudGhpbnRzbWV0YXRhZy5qc1xuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIE1ldGEgdGFnIHRoYXQgZW5hYmxlcyBDbGllbnQtSGludHMgZm9yIHRoZSBIVE1MIHBhZ2UuIDxici8+XG4gKiAgU2VlXG4gKiAgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9yZXNwb25zaXZlX2ltYWdlcyNhdXRvbWF0aW5nX3Jlc3BvbnNpdmVfaW1hZ2VzX3dpdGhfY2xpZW50X2hpbnRzXCJcbiAqICB0YXJnZXQ9XCJfbmV3XCI+QXV0b21hdGluZyByZXNwb25zaXZlIGltYWdlcyB3aXRoIENsaWVudCBIaW50czwvYT4gZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBjb25zdHJ1Y3RvciBDbGllbnRIaW50c01ldGFUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAZXhhbXBsZVxuICogdGFnID0gbmV3IENsaWVudEhpbnRzTWV0YVRhZygpXG4gKiAvL3JldHVybnM6IDxtZXRhIGh0dHAtZXF1aXY9XCJBY2NlcHQtQ0hcIiBjb250ZW50PVwiRFBSLCBWaWV3cG9ydC1XaWR0aCwgV2lkdGhcIj5cbiAqL1xuXG52YXIgY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzKENsaWVudEhpbnRzTWV0YVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlU3VwZXIoQ2xpZW50SGludHNNZXRhVGFnKTtcblxuICBmdW5jdGlvbiBDbGllbnRIaW50c01ldGFUYWcob3B0aW9ucykge1xuICAgIGNsaWVudGhpbnRzbWV0YXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnRIaW50c01ldGFUYWcpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdtZXRhJywgdm9pZCAwLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgIFwiaHR0cC1lcXVpdlwiOiBcIkFjY2VwdC1DSFwiLFxuICAgICAgY29udGVudDogXCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiXG4gICAgfSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDbGllbnRIaW50c01ldGFUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaWVudEhpbnRzTWV0YVRhZztcbn0oaHRtbHRhZyk7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudGhpbnRzbWV0YXRhZyA9IChjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvcGFyc2Uvbm9ybWFsaXplVG9BcnJheS5qc1xuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKipcbiAqIEBkZXNjIG5vcm1hbGl6ZSBlbGVtZW50cywgc3VwcG9ydCBhIHNpbmdsZSBlbGVtZW50LCBhcnJheSBvciBub2RlbGlzdCwgYWx3YXlzIG91dHB1dHMgYXJyYXlcbiAqIEBwYXJhbSBlbGVtZW50czxIVE1MRWxlbWVudFtdPlxuICogQHJldHVybnMge1tdfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudHMpIHtcbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShlbGVtZW50cykpIHtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJOb2RlTGlzdFwiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkoZWxlbWVudHMpOyAvLyBlbnN1cmUgYW4gYXJyYXkgaXMgYWx3YXlzIHJldHVybmVkLCBldmVuIGlmIG5vZGVsaXN0XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2VsZW1lbnRzXTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnLmpzXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICogQHBhcmFtIHtvYmplY3R9IGNsSW5zdGFuY2UgY2xvdWRpbmFyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRyYW5zZm9ybWF0aW9uT3B0aW9uc1xuICogQHJldHVybnMgUHJvbWlzZTxIVE1MRWxlbWVudD5cbiAqL1xuZnVuY3Rpb24gbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcoaHRtbEVsQ29udGFpbmVyLCBjbEluc3RhbmNlLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGh0bWxFbENvbnRhaW5lci5pbm5lckhUTUwgPSBjbEluc3RhbmNlLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTsgLy8gQWxsIHZpZGVvcyB1bmRlciB0aGUgaHRtbCBjb250YWluZXIgbXVzdCBoYXZlIGEgd2lkdGggb2YgMTAwJSwgb3IgdGhleSBtaWdodCBvdmVyZmxvdyBmcm9tIHRoZSBjb250YWluZXJcblxuICAgIHZhciBjbG91ZGluYXJ5VmlkZW9FbGVtZW50ID0gaHRtbEVsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGQtdHJhbnNwYXJlbnQtdmlkZW8nKTtcbiAgICBjbG91ZGluYXJ5VmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcgPSAobW91bnRDbG91ZGluYXJ5VmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC90cmFuc2Zvcm1hdGlvbnMvYWRkRmxhZy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBGdW5jdGlvbiB3aWxsIHB1c2ggYSBmbGFnIHRvIGluY29taW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7e3RyYW5zZm9ybWF0aW9ufSB8IHsuLi50cmFuc2Zvcm1hdGlvbn19IG9wdGlvbnMgLSBUaGVzZSBvcHRpb25zIGFyZSB0aGUgc2FtZSBvcHRpb25zIHByb3ZpZGVkIHRvIGFsbCBvdXIgU0RLIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgV2UgZXhwZWN0IG9wdGlvbnMgdG8gZWl0aGVyIGJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpdHNlbGYsIG9yIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCBvcHRpb25zIG9iamVjdFxuICovXG5mdW5jdGlvbiBhZGRGbGFnVG9PcHRpb25zKG9wdGlvbnMsIGZsYWcpIHtcbiAgLy8gRG8gd2UgaGF2ZSB0cmFuc2Zvcm1hdGlvblxuICBpZiAob3B0aW9ucy50cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICBmbGFnczogW2ZsYWddXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdHJhbnNmb3JtYXRpb25cbiAgICAvLyBlbnN1cmUgdGhlIGZsYWdzIGFyZSBleHRlbmRlZFxuICAgIGlmICghb3B0aW9ucy5mbGFncykge1xuICAgICAgb3B0aW9ucy5mbGFncyA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMuZmxhZ3MgPSBbb3B0aW9ucy5mbGFnc107XG4gICAgfVxuXG4gICAgb3B0aW9ucy5mbGFncy5wdXNoKGZsYWcpO1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFkZEZsYWcgPSAoYWRkRmxhZ1RvT3B0aW9ucyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBFbmZvcmNlIG9wdGlvbiBzdHJ1Y3R1cmUsIHNldHMgZGVmYXVsdHMgYW5kIGVuc3VyZXMgYWxwaGEgZmxhZyBleGlzdHNcbiAqIEBwYXJhbSBvcHRpb25zIHtUcmFuc2Zvcm1hdGlvbk9wdGlvbnN9XG4gKi9cblxuZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5hdXRvcGxheSA9IHRydWU7XG4gIG9wdGlvbnMubXV0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmNvbnRyb2xzID0gZmFsc2U7XG4gIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgPSBvcHRpb25zLm1heF90aW1lb3V0X21zIHx8IERFRkFVTFRfVElNRU9VVF9NUztcbiAgb3B0aW9uc1tcImNsYXNzXCJdID0gb3B0aW9uc1tcImNsYXNzXCJdIHx8ICcnO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gKz0gJyBjbGQtdHJhbnNwYXJlbnQtdmlkZW8nO1xuICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzID0gb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcyB8fCB7fTtcblxuICBpZiAoIW9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSkge1xuICAgIG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSA9IERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTLnNlZVRocnU7XG4gIH0gLy8gZW5zdXJlIHRoZXJlJ3MgYW4gYWxwaGEgdHJhbnNmb3JtYXRpb24gcHJlc2VudFxuICAvLyB0aGlzIGlzIGEgbm9uIGRvY3VtZW50ZWQgaW50ZXJuYWwgZmxhZ1xuXG5cbiAgYWRkRmxhZyhvcHRpb25zLCAnYWxwaGEnKTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8gPSAoZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2xvYWRTY3JpcHQuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gR2l2ZW4gYSBzdHJpbmcgVVJMLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCB0aGUgc2NyaXB0IGFuZCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICogICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgcmVzb2x2ZSBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICB0aGlzIGlzIG5vdCBhIFVNRCBsb2FkZXIgd2hlcmUgeW91IGNhbiBnZXQgeW91ciBsaWJyYXJ5IG5hbWUgYmFjay5cbiAqIEBwYXJhbSBzY3JpcHRVUkwge3N0cmluZ31cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0gaXNBbHJlYWR5TG9hZGVkIHtib29sZWFufSBpZiB0cnVlLCB0aGUgbG9hZFNjcmlwdCByZXNvbHZlcyBpbW1lZGlhdGVseVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpcyB1c2VkIGZvciBtdWx0aXBsZSBpbnZvY2F0aW9ucyAtIHByZXZlbnRzIHRoZSBzY3JpcHQgZnJvbSBiZWluZyBsb2FkZWQgbXVsdGlwbGUgdGltZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gKi9cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0VVJMLCBtYXhfdGltZW91dF9tcywgaXNBbHJlYWR5TG9hZGVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGlzQWxyZWFkeUxvYWRlZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRUYWcuc3JjID0gc2NyaXB0VVJMO1xuICAgICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJUaW1lb3V0IGxvYWRpbmcgc2NyaXB0IFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfSwgbWF4X3RpbWVvdXRfbXMpOyAvLyAxMCBzZWNvbmRzIGZvciB0aW1lb3V0XG5cbiAgICAgIHNjcmlwdFRhZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG5cbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBsb2FkaW5nIFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgc2NyaXB0VGFnLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpOyAvLyBjbGVhciB0aW1lb3V0IHJlamVjdCBlcnJvclxuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfbG9hZFNjcmlwdCA9IChsb2FkU2NyaXB0KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2dldEJsb2JGcm9tVVJMLmpzXG4vKipcbiAqIFJlamVjdCBvbiB0aW1lb3V0XG4gKiBAcGFyYW0gbWF4VGltZW91dE1TXG4gKiBAcGFyYW0gcmVqZWN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aW1lcklEXG4gKi9cbmZ1bmN0aW9uIHJlamVjdE9uVGltZW91dChtYXhUaW1lb3V0TVMsIHJlamVjdCkge1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmVqZWN0KHtcbiAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IGxvYWRpbmcgQmxvYiBVUkwnXG4gICAgfSk7XG4gIH0sIG1heFRpbWVvdXRNUyk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyBhIFVSTCB0byBhIEJMT0IgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsVG9Mb2FkXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybiB7UHJvbWlzZTx7XG4gKiAgIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2Vycm9yJ1xuICogICBtZXNzYWdlPzogc3RyaW5nLFxuICogICAgcGF5bG9hZDoge1xuICogICAgICB1cmw6IHN0cmluZ1xuICogICAgfVxuICogfT59XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCbG9iRnJvbVVSTCh1cmxUb0xvYWQsIG1heFRpbWVvdXRNUykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KTsgLy8gSWYgZmV0Y2ggZXhpc3RzLCB1c2UgaXQgdG8gZmV0Y2ggYmxvYiwgb3RoZXJ3aXNlIHVzZSBYSFIuXG4gICAgLy8gWEhSIGNhdXNlcyBpc3N1ZXMgb24gc2FmYXJpIDE0LjEgc28gd2UgcHJlZmVyIGZldGNoXG5cbiAgICB2YXIgZmV0Y2hCbG9iID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyAmJiBmZXRjaCA/IGxvYWRVcmxVc2luZ0ZldGNoIDogbG9hZFVybFVzaW5nWGhyO1xuICAgIGZldGNoQmxvYih1cmxUb0xvYWQpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGJsb2JVUkw6IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIEJsb2IgVVJMJ1xuICAgICAgfSk7XG4gICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0IHRpbWVyIG9uIGZhaWwgb3Igc3VjY2Vzcy5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIFVzZSBmZXRjaCBmdW5jdGlvbiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRVcmxVc2luZ0ZldGNoKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZldGNoKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmJsb2IoKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCgnZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIFVzZSBYSFIgdG8gZmV0Y2ggZmlsZVxuICogQHBhcmFtIHVybFRvTG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkVXJsVXNpbmdYaHIodXJsVG9Mb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJsVG9Mb2FkLCB0cnVlKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyX2dldEJsb2JGcm9tVVJMID0gKGdldEJsb2JGcm9tVVJMKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9jcmVhdGVIaWRkZW5WaWRlb1RhZy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIGhpZGRlbiBIVE1MVmlkZW9FbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB2aWRlb09wdGlvbnNcbiAqIEBwYXJhbSB7e2F1dG9wbGF5LCBwbGF5c2lubGluZSwgbG9vcCwgbXV0ZWQsIHBvc3RlciwgYmxvYlVSTCwgdmlkZW9VUkwgfX0gdmlkZW9PcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZpZGVvT3B0aW9ucy5hdXRvcGxheSAtIGF1dG9wbGF5cyB0aGUgdmlkZW8gaWYgdHJ1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvT3B0aW9ucy5ibG9iVVJMIC0gdGhlIGJsb2JVUkwgdG8gc2V0IGFzIHZpZGVvLnNyY1xuICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvT3B0aW9ucy52aWRlb1VSTCAtIHRoZSBvcmlnaW5hbCB2aWRlb1VSTCB0aGUgdXNlciBjcmVhdGVkICh3aXRoIHRyYW5zZm9ybWF0aW9ucylcbiAqIEByZXR1cm4ge0hUTUxWaWRlb0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhpZGRlblZpZGVvVGFnKHZpZGVvT3B0aW9ucykge1xuICB2YXIgYXV0b3BsYXkgPSB2aWRlb09wdGlvbnMuYXV0b3BsYXksXG4gICAgICBwbGF5c2lubGluZSA9IHZpZGVvT3B0aW9ucy5wbGF5c2lubGluZSxcbiAgICAgIGxvb3AgPSB2aWRlb09wdGlvbnMubG9vcCxcbiAgICAgIG11dGVkID0gdmlkZW9PcHRpb25zLm11dGVkLFxuICAgICAgcG9zdGVyID0gdmlkZW9PcHRpb25zLnBvc3RlcixcbiAgICAgIGJsb2JVUkwgPSB2aWRlb09wdGlvbnMuYmxvYlVSTCxcbiAgICAgIHZpZGVvVVJMID0gdmlkZW9PcHRpb25zLnZpZGVvVVJMO1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGVsLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZWwueCA9IDA7XG4gIGVsLnkgPSAwO1xuICBlbC5zcmMgPSBibG9iVVJMO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlkZW8tdXJsJywgdmlkZW9VUkwpOyAvLyBmb3IgZGVidWdnaW5nL3Rlc3RpbmdcblxuICBhdXRvcGxheSAmJiBlbC5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgYXV0b3BsYXkpO1xuICBwbGF5c2lubGluZSAmJiBlbC5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgcGxheXNpbmxpbmUpO1xuICBsb29wICYmIGVsLnNldEF0dHJpYnV0ZSgnbG9vcCcsIGxvb3ApO1xuICBtdXRlZCAmJiBlbC5zZXRBdHRyaWJ1dGUoJ211dGVkJywgbXV0ZWQpO1xuICBtdXRlZCAmJiAoZWwubXV0ZWQgPSBtdXRlZCk7IC8vIHRoaXMgaXMgYWxzbyBuZWVkZWQgZm9yIGF1dG9wbGF5LCBvbiB0b3Agb2Ygc2V0QXR0cmlidXRlXG5cbiAgcG9zdGVyICYmIGVsLnNldEF0dHJpYnV0ZSgncG9zdGVyJywgcG9zdGVyKTsgLy8gRnJlZSBtZW1vcnkgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZSBsb2FkaW5nLlxuXG4gIGVsLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICB9O1xuXG4gIHJldHVybiBlbDtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyA9IChjcmVhdGVIaWRkZW5WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vaW5zdGFudGlhdGVTZWVUaHJ1LmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgaW5zdGFuYyBlb2Ygc2VlVGhydSAoc2VlVGhydS5jcmVhdGUoKSkgYW5kIHJldHVybnMgYSBwcm9taXNlIG9mIHRoZSBzZWVUaHJ1IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvRWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b21DbGFzcyAtIEEgY2xhc3NuYW1lIHRvIGJlIGFkZGVkIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjcmVhdGVkIGJ5IHNlZVRocnVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b1BsYXlcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn0gU2VlVGhydSBpbnN0YW5jZSBvciByZWplY3Rpb24gZXJyb3JcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTZWVUaHJ1KHZpZGVvRWxlbWVudCwgbWF4X3RpbWVvdXRfbXMsIGN1c3RvbUNsYXNzLCBhdXRvUGxheSkge1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIHNlZVRocnUgPSBfd2luZG93LnNlZVRocnUsXG4gICAgICBzZXRUaW1lb3V0ID0gX3dpbmRvdy5zZXRUaW1lb3V0LFxuICAgICAgY2xlYXJUaW1lb3V0ID0gX3dpbmRvdy5jbGVhclRpbWVvdXQ7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ1RpbWVvdXQgaW5zdGFudGlhdGluZyBzZWVUaHJ1IGluc3RhbmNlJ1xuICAgICAgfSk7XG4gICAgfSwgbWF4X3RpbWVvdXRfbXMpO1xuXG4gICAgaWYgKHNlZVRocnUpIHtcbiAgICAgIHZhciBzZWVUaHJ1SW5zdGFuY2UgPSBzZWVUaHJ1LmNyZWF0ZSh2aWRlb0VsZW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpOyAvLyBmb3JjZSBjb250YWluZXIgd2lkdGgsIGVsc2UgdGhlIGNhbnZhcyBjYW4gb3ZlcmZsb3cgb3V0XG5cbiAgICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSBzZWVUaHJ1SW5zdGFuY2UuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGN1c3RvbUNsYXNzOyAvLyBzdGFydCB0aGUgdmlkZW8gaWYgYXV0b3BsYXkgaXMgc2V0XG5cbiAgICAgICAgaWYgKGF1dG9QbGF5KSB7XG4gICAgICAgICAgc2VlVGhydUluc3RhbmNlLnBsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoc2VlVGhydUluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSA9IChpbnN0YW50aWF0ZVNlZVRocnUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL21vdW50U2VlVGhydUNhbnZhc1RhZy5qc1xuXG5cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb1VSTFxuICogQHBhcmFtIHtUcmFuc2Zvcm1hdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuXG5mdW5jdGlvbiBtb3VudFNlZVRocnVDYW52YXNUYWcoaHRtbEVsQ29udGFpbmVyLCB2aWRlb1VSTCwgb3B0aW9ucykge1xuICB2YXIgcG9zdGVyID0gb3B0aW9ucy5wb3N0ZXIsXG4gICAgICBhdXRvcGxheSA9IG9wdGlvbnMuYXV0b3BsYXksXG4gICAgICBwbGF5c2lubGluZSA9IG9wdGlvbnMucGxheXNpbmxpbmUsXG4gICAgICBsb29wID0gb3B0aW9ucy5sb29wLFxuICAgICAgbXV0ZWQgPSBvcHRpb25zLm11dGVkO1xuICB2aWRlb1VSTCA9IHZpZGVvVVJMICsgJy5tcDQnOyAvLyBzZWVUaHJ1IGFsd2F5cyB1c2VzIG1wNFxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgeGhyX2xvYWRTY3JpcHQob3B0aW9ucy5leHRlcm5hbExpYnJhcmllcy5zZWVUaHJ1LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCB3aW5kb3cuc2VlVGhydSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB4aHJfZ2V0QmxvYkZyb21VUkwodmlkZW9VUkwsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBfcmVmLnBheWxvYWQ7XG4gICAgICAgIHZhciB2aWRlb0VsZW1lbnQgPSB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnKHtcbiAgICAgICAgICBibG9iVVJMOiBwYXlsb2FkLmJsb2JVUkwsXG4gICAgICAgICAgdmlkZW9VUkw6IHZpZGVvVVJMLFxuICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuICAgICAgICAgIHBvc3RlcjogcG9zdGVyLFxuICAgICAgICAgIGF1dG9wbGF5OiBhdXRvcGxheSxcbiAgICAgICAgICBwbGF5c2lubGluZTogcGxheXNpbmxpbmUsXG4gICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICBtdXRlZDogbXV0ZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGh0bWxFbENvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSh2aWRlb0VsZW1lbnQsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMsIG9wdGlvbnNbXCJjbGFzc1wiXSwgb3B0aW9ucy5hdXRvcGxheSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7IC8vIGNhdGNoIGZvciBnZXRCbG9iRnJvbVVSTCgpXG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2U7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBjYXRjaCBmb3IgbG9hZFNjcmlwdCgpXG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBzdGF0dXMgPSBfcmVmMy5zdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2U7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyA9IChtb3VudFNlZVRocnVDYW52YXNUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeS5qc1xuLyoqXG4gKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSAtIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNwYXJlbnQgdmlkZW9zIG9yIG5vdFxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIFJlc29sdmUgZWFybHkgZm9yIHNhZmFyaS5cbiAgICAvLyBDdXJyZW50bHkgKDI5IERlY2VtYmVyIDIwMjEpIFNhZmFyaSBjYW4gcGxheSB3ZWJtL3ZwOSxcbiAgICAvLyBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydCB0cmFuc3BhcmVudCB2aWRlbyBpbiB0aGUgZm9ybWF0IHdlJ3JlIG91dHB1dHRpbmdcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2YXIgY2FuUGxheSA9IHZpZGVvLmNhblBsYXlUeXBlICYmIHZpZGVvLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDlcIicpO1xuICAgIHJlc29sdmUoY2FuUGxheSA9PT0gJ21heWJlJyB8fCBjYW5QbGF5ID09PSAncHJvYmFibHknKTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5ID0gKGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jbG91ZGluYXJ5LmpzXG5mdW5jdGlvbiBjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG52YXIgYXBwbHlCcmVha3BvaW50cywgY2xvc2VzdEFib3ZlLCBkZWZhdWx0QnJlYWtwb2ludHMsIGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoLCBjbG91ZGluYXJ5X21heFdpZHRoLCB1cGRhdGVEcHI7XG5cblxuXG5cblxuXG5cblxuXG4gLy9cblxuXG5cblxuXG5cbmRlZmF1bHRCcmVha3BvaW50cyA9IGZ1bmN0aW9uIGRlZmF1bHRCcmVha3BvaW50cyh3aWR0aCkge1xuICB2YXIgc3RlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgcmV0dXJuIHN0ZXBzICogTWF0aC5jZWlsKHdpZHRoIC8gc3RlcHMpO1xufTtcblxuY2xvc2VzdEFib3ZlID0gZnVuY3Rpb24gY2xvc2VzdEFib3ZlKGxpc3QsIHZhbHVlKSB7XG4gIHZhciBpO1xuICBpID0gbGlzdC5sZW5ndGggLSAyO1xuXG4gIHdoaWxlIChpID49IDAgJiYgbGlzdFtpXSA+PSB2YWx1ZSkge1xuICAgIGktLTtcbiAgfVxuXG4gIHJldHVybiBsaXN0W2kgKyAxXTtcbn07XG5cbmFwcGx5QnJlYWtwb2ludHMgPSBmdW5jdGlvbiBhcHBseUJyZWFrcG9pbnRzKHRhZywgd2lkdGgsIHN0ZXBzLCBvcHRpb25zKSB7XG4gIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzO1xuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9IChyZWYgPSAocmVmMSA9IChyZWYyID0gb3B0aW9uc1sncmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMnXSkgIT0gbnVsbCA/IHJlZjIgOiBvcHRpb25zWydyZXNwb25zaXZlX3VzZV9zdG9wcG9pbnRzJ10pICE9IG51bGwgPyByZWYxIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJykpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cycpO1xuXG4gIGlmICghcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgfHwgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgPT09ICdyZXNpemUnICYmICFvcHRpb25zLnJlc2l6aW5nKSB7XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmNhbGNfYnJlYWtwb2ludCh0YWcsIHdpZHRoLCBzdGVwcyk7XG4gIH1cbn07XG5cbmNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24gZmluZENvbnRhaW5lcldpZHRoKGVsZW1lbnQpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBzdHlsZTtcbiAgY29udGFpbmVyV2lkdGggPSAwO1xuXG4gIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQucGFyZW50Tm9kZSA6IHZvaWQgMCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFjb250YWluZXJXaWR0aCkge1xuICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoIS9eaW5saW5lLy50ZXN0KHN0eWxlLmRpc3BsYXkpKSB7XG4gICAgICBjb250YWluZXJXaWR0aCA9IGxvZGFzaF93aWR0aChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyV2lkdGg7XG59O1xuXG51cGRhdGVEcHIgPSBmdW5jdGlvbiB1cGRhdGVEcHIoZGF0YVNyYywgcm91bmREcHIpIHtcbiAgcmV0dXJuIGRhdGFTcmMucmVwbGFjZSgvXFxiZHByXygxXFwuMHxhdXRvKVxcYi9nLCAnZHByXycgKyB0aGlzLmRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikpO1xufTtcblxuY2xvdWRpbmFyeV9tYXhXaWR0aCA9IGZ1bmN0aW9uIG1heFdpZHRoKHJlcXVpcmVkV2lkdGgsIHRhZykge1xuICB2YXIgaW1hZ2VXaWR0aDtcbiAgaW1hZ2VXaWR0aCA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3dpZHRoJykgfHwgMDtcblxuICBpZiAocmVxdWlyZWRXaWR0aCA+IGltYWdlV2lkdGgpIHtcbiAgICBpbWFnZVdpZHRoID0gcmVxdWlyZWRXaWR0aDtcbiAgICBsb2Rhc2hfc2V0RGF0YSh0YWcsICd3aWR0aCcsIHJlcXVpcmVkV2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIGltYWdlV2lkdGg7XG59O1xuXG52YXIgY2xvdWRpbmFyeV9DbG91ZGluYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ2xvdWRpbmFyeSBpbnN0YW5jZS5cbiAgICogQGNsYXNzIENsb3VkaW5hcnlcbiAgICogQGNsYXNzZGVzYyBNYWluIGNsYXNzIGZvciBhY2Nlc3NpbmcgQ2xvdWRpbmFyeSBmdW5jdGlvbmFsaXR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEEge0BsaW5rIENvbmZpZ3VyYXRpb259IG9iamVjdCBmb3IgZ2xvYmFsbHkgY29uZmlndXJpbmcgQ2xvdWRpbmFyeSBhY2NvdW50IHNldHRpbmdzLlxuICAgKiBAZXhhbXBsZTxici8+XG4gICAqICB2YXIgY2wgPSBuZXcgY2xvdWRpbmFyeS5DbG91ZGluYXJ5KCB7IGNsb3VkX25hbWU6IFwibXljbG91ZFwifSk7PGJyLz5cbiAgICogIHZhciBpbWdUYWcgPSBjbC5pbWFnZShcIm15UGljSURcIik7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICogIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAqL1xuICBmdW5jdGlvbiBDbG91ZGluYXJ5KG9wdGlvbnMpIHtcbiAgICBjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsb3VkaW5hcnkpO1xuXG4gICAgdmFyIGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGNvbmZpZ3VyYXRpb24gPSBuZXcgc3JjX2NvbmZpZ3VyYXRpb24ob3B0aW9ucyk7IC8vIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICB0aGlzLmNvbmZpZyA9IGZ1bmN0aW9uIChuZXdDb25maWcsIG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5jb25maWcobmV3Q29uZmlnLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgXFw8bWV0YVxcPiB0YWdzIGluIHRoZSBkb2N1bWVudCB0byBjb25maWd1cmUgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIHRoaXMuZnJvbURvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRG9jdW1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byBjb25maWd1cmUgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIHRoaXMuZnJvbUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBpbnZva2VzIGJvdGgge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfVxuICAgICAqICAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KSBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICAgKiAgSXQgZmlyc3QgdHJpZXMgdG8gcmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbml0XG4gICAgICogQHNlZSBDb25maWd1cmF0aW9uI2luaXRcbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5pbml0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtDbG91ZGluYXJ5fVxuICAgKiBAZXhhbXBsZSBjbCA9IGNsb3VkaW5hcnkuQ2xvdWRpbmFyeS5uZXcoIHsgY2xvdWRfbmFtZTogXCJteWNsb3VkXCJ9KVxuICAgKi9cblxuXG4gIGNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MoQ2xvdWRpbmFyeSwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbnkgYXNzZXQgaW4geW91ciBNZWRpYSBsaWJyYXJ5LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIG1lZGlhIGFzc2V0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25zI2ZldGNoaW5nX2ltYWdlc19mcm9tX3JlbW90ZV9sb2NhdGlvbnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5GZXRjaCB0eXBlczwvYT4uXG4gICAgICogQHBhcmFtIHtyZXNvdXJjZVR5cGV9IFtvcHRpb25zLnJlc291cmNlX3R5cGU9J2ltYWdlJ10gLSBUaGUgdHlwZSBvZiBhc3NldC4gUG9zc2libGUgdmFsdWVzOjxici8+XG4gICAgICogIC0gYGltYWdlYDxici8+XG4gICAgICogIC0gYHZpZGVvYDxici8+XG4gICAgICogIC0gYHJhd2BcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtZWRpYSBhc3NldCBVUkwuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cmwocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB1cmxfdXJsKHB1YmxpY0lkLCBvcHRpb25zLCB0aGlzLmNvbmZpZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gYXNzZXQgVVJMLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZpZGVvIFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb191cmwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFuIGltYWdlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0aHVtYm5haWwgZm9yIHRoZSBzcGVjaWZpZWQgdmlkZW8uXG4gICAgICogIElkZW50aWNhbCB0byB7QGxpbmsgQ2xvdWRpbmFyeSN1cmx8dXJsfSwgZXhjZXB0IHRoYXQgdGhlIGByZXNvdXJjZV90eXBlYCBpcyBgdmlkZW9gXG4gICAgICogIGFuZCB0aGUgZGVmYXVsdCBgZm9ybWF0YCBpcyBganBnYC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB3aGljaCB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIGltYWdlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJuYWlsLlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHN0YW5kYXJkIGltYWdlIHRyYW5zZm9ybWF0aW9ucywgeW91IGNhbiBhbHNvIHVzZSB0aGUgYHN0YXJ0X29mZnNldGAgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogdG8gaW5zdHJ1Y3QgQ2xvdWRpbmFyeSB0byBnZW5lcmF0ZSB0aGUgdGh1bWJuYWlsIGZyb20gYSBmcmFtZSBvdGhlciB0aGFuIHRoZSBtaWRkbGUgZnJhbWUgb2YgdGhlIHZpZGVvLlxuICAgICAqIEZvciBkZXRhaWxzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX21hbmlwdWxhdGlvbl9hbmRfZGVsaXZlcnkjZ2VuZXJhdGluZ192aWRlb190aHVtYm5haWxzXCJcbiAgICAgKiB0YXJnZXQ9XCJfYmxhbmtcIj5HZW5lcmF0aW5nIHZpZGVvIHRodW1ibmFpbHM8L2E+IGluIHRoZSBDbG91ZGluYXJ5IGRvY3VtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHZpZGVvIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb190aHVtYm5haWxfdXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbF91cmwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25fc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2Zvcm1hdGlvbiBzdHJpbmcuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uX3N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucykuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZShwdWJsaWNJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNsaWVudF9oaW50cywgaW1nLCByZWY7XG4gICAgICBpbWcgPSB0aGlzLmltYWdlVGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIGNsaWVudF9oaW50cyA9IChyZWYgPSBvcHRpb25zLmNsaWVudF9oaW50cyAhPSBudWxsID8gb3B0aW9ucy5jbGllbnRfaGludHMgOiB0aGlzLmNvbmZpZygnY2xpZW50X2hpbnRzJykpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcblxuICAgICAgaWYgKG9wdGlvbnMuc3JjID09IG51bGwgJiYgIWNsaWVudF9oaW50cykge1xuICAgICAgICAvLyBzcmMgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSBjcmVhdGluZyB0aGUgRE9NIGVsZW1lbnQgdG8gYXZvaWQgbG9hZGluZyB0aGUgaW1hZ2VcbiAgICAgICAgaW1nLnNldEF0dHIoXCJzcmNcIiwgJycpO1xuICAgICAgfVxuXG4gICAgICBpbWcgPSBpbWcudG9ET00oKTtcblxuICAgICAgaWYgKCFjbGllbnRfaGludHMpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGltYWdlIHNyY1xuICAgICAgICBsb2Rhc2hfc2V0RGF0YShpbWcsICdzcmMtY2FjaGUnLCB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucykpOyAvLyBzZXQgaW1hZ2Ugc3JjIHRha2luZyByZXNwb25zaXZlbmVzcyBpbiBhY2NvdW50XG5cbiAgICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWcsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEltYWdlVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ltYWdlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0ltYWdlVGFnfSBBbiBJbWFnZVRhZyBpbnN0YW5jZSB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgaW1hZ2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBpY3R1cmVUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjUGljdHVyZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IEltYWdlVGFnIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgZGVmaW5pdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQaWN0dXJlVGFnfSBBIFBpY3R1cmVUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwaWN0dXJlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpY3R1cmVUYWcocHVibGljSWQsIG9wdGlvbnMsIHNvdXJjZXMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgcGljdHVyZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSwgc291cmNlcyk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU291cmNlVGFnIGluc3RhbmNlLCBjb25maWd1cmVkIHVzaW5nIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I1NvdXJjZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtTb3VyY2VUYWd9IEEgU291cmNlVGFnIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBzb3VyY2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0aHVtYm5haWwgVVJMIGZyb20gdGhlIHNwZWNpZmllZCByZW1vdGUgdmlkZW8gYW5kIGluY2x1ZGVzIGl0IGluIGFuIGltYWdlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHZpZGVvIGZyb20gdGhlIHJlbGV2YW50IHZpZGVvIHNpdGUuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIGlkZW50aWZpZXIgdmFsdWUgb3Igc2V0XG4gICAgICogIHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgWW91VHViZSB2aWRlbyBtaWdodCBoYXZlIHRoZSBpZGVudGlmaWVyOiAnby11cm5sYUpwT0EuanBnJy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBIVE1MIGltYWdlIHRhZyBlbGVtZW50XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmYWNlYm9vayBwcm9maWxlIGltYWdlIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmYWNlYm9va19wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIEZhY2Vib29rIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZWJvb2tfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZmFjZWJvb2snXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgSUQgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3R3aXR0ZXJfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgbmFtZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgVHdpdHRlciBzY3JlZW4gbmFtZS4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXJfbmFtZSdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEdyYXZhdGFyIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2dyYXZhdGFyX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIGNhbGN1bGF0ZWQgaGFzaCBmb3IgdGhlIEdyYXZhdGFyIGVtYWlsIGFkZHJlc3MuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIHNjcmVlbiBuYW1lIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0XG4gICAgICogIGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdyYXZhdGFyX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZhdGFyX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdncmF2YXRhcidcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbiBpbWFnZSBmcm9tIGEgcmVtb3RlIFVSTCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZmV0Y2hfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIGltYWdlIHRvIGZldGNoLCBpbmNsdWRpbmcgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH0gQSB2aWRlbyB0YWcgRE9NIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW8ocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWaWRlb1RhZyBpbnN0YW5jZSB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBkZWZpbmVkIGZvciB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1RhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7VmlkZW9UYWd9IEEgVmlkZW9UYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgICByZXR1cm4gbmV3IHZpZGVvdGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc3ByaXRlIFBORyBpbWFnZSB0aGF0IGNvbnRhaW5zIGFsbCBpbWFnZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY3NzIGZpbGUuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjc3ByaXRlX2Nzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB0YWcgb24gd2hpY2ggdG8gYmFzZSB0aGUgc3ByaXRlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGdlbmVyYXRlZCBDU1MgZmlsZS4gVGhlIHNwcml0ZSBpbWFnZSBoYXMgdGhlIHNhbWUgVVJMLCBidXQgd2l0aCBhIFBORyBleHRlbnNpb24uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Nwcml0ZV9nZW5lcmF0aW9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIFNwcml0ZSBnZW5lcmF0aW9uPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwcml0ZV9jc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ByaXRlX2NzcyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnc3ByaXRlJ1xuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghcHVibGljSWQubWF0Y2goLy5jc3MkLykpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSAnY3NzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcmVzcG9uc2l2ZSBpbWFnZSBiZWhhdmlvciBmb3IgYWxsIGltYWdlIHRhZ3Mgd2l0aCB0aGUgJ2NsZC1yZXNwb25zaXZlJ1xuICAgICAqICAob3Igb3RoZXIgZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9IGNsYXNzKS48YnIvPlxuICAgICAqICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCBhZnRlciB0aGUgcGFnZSBoYXMgbG9hZGVkLjxici8+XG4gICAgICogIDxiPk5vdGU8L2I+OiBDYWxscyB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gdG8gbW9kaWZ5IGltYWdlIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjcmVzcG9uc2l2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3M9J2NsZC1yZXNwb25zaXZlJ10gLSBBbiBhbHRlcm5hdGl2ZSBjbGFzc1xuICAgICAqICB0byBsb2NhdGUgdGhlIHJlbGV2YW50ICZsdDtpbWcmZ3Q7IHRhZ3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3BvbnNpdmVfZGVib3VuY2U9MTAwXSAtIFRoZSBkZWJvdW5jZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYm9vdHN0cmFwPXRydWVdIElmIHRydWUsIHByb2Nlc3NlcyB0aGUgJmx0O2ltZyZndDsgdGFncyBieSBjYWxsaW5nXG4gICAgICogIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfS4gV2hlbiBmYWxzZSwgdGhlIHRhZ3MgYXJlIHByb2Nlc3NlZFxuICAgICAqICBvbmx5IGFmdGVyIGEgcmVzaXplIGV2ZW50LlxuICAgICAqIEBzZWUge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IGZvciBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9yZXNwb25zaXZlX2ltYWdlcyNhdXRvbWF0aW5nX3Jlc3BvbnNpdmVfaW1hZ2VzX3dpdGhfamF2YXNjcmlwdFwiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF1dG9tYXRpbmcgcmVzcG9uc2l2ZSBpbWFnZXMgd2l0aCBKYXZhU2NyaXB0PC9hPlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGF0IHdoZW4gY2FsbGVkLCByZW1vdmVzIHRoZSByZXNpemUgRXZlbnRMaXN0ZW5lciBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNwb25zaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3BvbnNpdmUob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGJvb3RzdHJhcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVDbGFzcywgcmVzcG9uc2l2ZVJlc2l6ZSwgdGltZW91dDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXNwb25zaXZlQ2xhc3MgPSAocmVmID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3MpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuXG4gICAgICBpZiAoYm9vdHN0cmFwKSB7XG4gICAgICAgIHRoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcywgXCIsIGltZy5jbGQtaGlkcGlcIiksIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNpdmVSZXNpemUgPSAocmVmMSA9IChyZWYyID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfcmVzaXplKSAhPSBudWxsID8gcmVmMiA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3Jlc2l6ZScpKSAhPSBudWxsID8gcmVmMSA6IHRydWU7XG5cbiAgICAgIGlmIChyZXNwb25zaXZlUmVzaXplICYmICF0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzaXppbmcgPSB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIHZhciBtYWtlUmVzcG9uc2l2ZSA9IGZ1bmN0aW9uIG1ha2VSZXNwb25zaXZlKCkge1xuICAgICAgICAgIHZhciBkZWJvdW5jZSwgcmVmMywgcmVmNCwgcmVzZXQsIHJ1biwgd2FpdCwgd2FpdEZ1bmM7XG4gICAgICAgICAgZGVib3VuY2UgPSAocmVmMyA9IChyZWY0ID0gX3RoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2RlYm91bmNlKSAhPSBudWxsID8gcmVmNCA6IF90aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9kZWJvdW5jZScpKSAhPSBudWxsID8gcmVmMyA6IDEwMDtcblxuICAgICAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcyksIF90aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3YWl0RnVuYyA9IGZ1bmN0aW9uIHdhaXRGdW5jKCkge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBydW4oKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd2FpdCA9IGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQod2FpdEZ1bmMsIGRlYm91bmNlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBtYWtlUmVzcG9uc2l2ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBtYWtlUmVzcG9uc2l2ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2NhbGNfYnJlYWtwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY19icmVha3BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfYnJlYWtwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpIHtcbiAgICAgIHZhciBicmVha3BvaW50cyA9IGxvZGFzaF9nZXREYXRhKGVsZW1lbnQsICdicmVha3BvaW50cycpIHx8IGxvZGFzaF9nZXREYXRhKGVsZW1lbnQsICdzdG9wcG9pbnRzJykgfHwgdGhpcy5jb25maWcoJ2JyZWFrcG9pbnRzJykgfHwgdGhpcy5jb25maWcoJ3N0b3Bwb2ludHMnKSB8fCBkZWZhdWx0QnJlYWtwb2ludHM7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBicmVha3BvaW50cyh3aWR0aCwgc3RlcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGJyZWFrcG9pbnRzKSkge1xuICAgICAgICAgIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocG9pbnQpO1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZXN0QWJvdmUoYnJlYWtwb2ludHMsIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2FsY19zdG9wcG9pbnRcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNhbGNfYnJlYWtwb2ludH0gaW5zdGVhZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfc3RvcHBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfc3RvcHBvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2RldmljZV9waXhlbF9yYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXZpY2VfcGl4ZWxfcmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV2aWNlX3BpeGVsX3JhdGlvKHJvdW5kRHByKSB7XG4gICAgICByb3VuZERwciA9IHJvdW5kRHByID09IG51bGwgPyB0cnVlIDogcm91bmREcHI7XG4gICAgICB2YXIgZHByID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiB2b2lkIDApIHx8IDE7XG5cbiAgICAgIGlmIChyb3VuZERwcikge1xuICAgICAgICBkcHIgPSBNYXRoLmNlaWwoZHByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRwciA8PSAwIHx8IGRwciA9PT0gMCAvIDApIHtcbiAgICAgICAgZHByID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRwclN0cmluZyA9IGRwci50b1N0cmluZygpO1xuXG4gICAgICBpZiAoZHByU3RyaW5nLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICBkcHJTdHJpbmcgKz0gJy4wJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRwclN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBcHBsaWVzIHJlc3BvbnNpdmVuZXNzIHRvIGFsbCA8Y29kZT4mbHQ7aW1nJmd0OzwvY29kZT4gdGFncyB1bmRlciBlYWNoIHJlbGV2YW50IG5vZGVcbiAgICAqICAocmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB0YWcgY29udGFpbnMgdGhlIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0gY2xhc3MpLlxuICAgICogQHBhcmFtIHtFbGVtZW50W119IG5vZGVzIFRoZSBwYXJlbnQgbm9kZXMgd2hlcmUgeW91IHdhbnQgdG8gc2VhcmNoIGZvciAmbHQ7aW1nJmd0OyB0YWdzLlxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IG9wdGlvbnMgdG8gYXBwbHkuXG4gICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjcHJvY2Vzc0ltYWdlVGFnc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzSW1hZ2VUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NJbWFnZVRhZ3Mobm9kZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc0VtcHR5KG5vZGVzKSkge1xuICAgICAgICAvLyBzaW1pbGFyIHRvIGAkLmZuLmNsb3VkaW5hcnlgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMgfHwge30sIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdmFyIGltYWdlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gL15pbWckL2kudGVzdChub2RlLnRhZ05hbWUpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWdPcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICAgIHNyYzogbm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcHVibGljSWQgPSBpbWdPcHRpb25zWydzb3VyY2UnXSB8fCBpbWdPcHRpb25zWydzcmMnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NvdXJjZSddO1xuICAgICAgICBkZWxldGUgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIHZhciBhdHRyID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihpbWdPcHRpb25zKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGxvZGFzaF9zZXREYXRhKG5vZGUsICdzcmMtY2FjaGUnLCB1cmxfdXJsKHB1YmxpY0lkLCBpbWdPcHRpb25zKSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGF0dHIud2lkdGgpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYXR0ci5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWFnZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogVXBkYXRlcyB0aGUgZHByIChmb3IgYGRwcl9hdXRvYCkgYW5kIHJlc3BvbnNpdmUgKGZvciBgd19hdXRvYCkgZmllbGRzIGFjY29yZGluZyB0b1xuICAgICogIHRoZSBjdXJyZW50IGNvbnRhaW5lciBzaXplIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLjxici8+XG4gICAgKiAgPGI+Tm90ZTwvYj46YHdfYXV0b2AgaXMgdXBkYXRlZCBvbmx5IGZvciBpbWFnZXMgbWFya2VkIHdpdGggdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9KSBjbGFzcy5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlXG4gICAgKiBAcGFyYW0geyhBcnJheXxzdHJpbmd8Tm9kZUxpc3QpfSBlbGVtZW50cyAtIFRoZSBIVE1MIGltYWdlIGVsZW1lbnRzIHRvIG1vZGlmeS5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX3VzZV9icmVha3BvaW50cz10cnVlXVxuICAgICogUG9zc2libGUgdmFsdWVzOjxici8+XG4gICAgKiAgLSBgdHJ1ZWA6IEFsd2F5cyB1c2UgYnJlYWtwb2ludHMgZm9yIHdpZHRoLjxici8+XG4gICAgKiAgLSBgcmVzaXplYDogVXNlIGV4YWN0IHdpZHRoIG9uIGZpcnN0IHJlbmRlciBhbmQgYnJlYWtwb2ludHMgb24gcmVzaXplLjxici8+XG4gICAgKiAgLSBgZmFsc2VgOiBBbHdheXMgdXNlIGV4YWN0IHdpZHRoLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNwb25zaXZlXSAtIElmIGB0cnVlYCwgZW5hYmxlIHJlc3BvbnNpdmUgb24gYWxsIHNwZWNpZmllZCBlbGVtZW50cy5cbiAgICAqICBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGRlZmluZSBzcGVjaWZpYyBIVE1MIGVsZW1lbnRzIHRvIG1vZGlmeSBieSBhZGRpbmcgdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgY3VzdG9tLWRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlX2NsYXNzfSkgY2xhc3MgdG8gdGhvc2UgZWxlbWVudHMuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0XSAtIElmIGB0cnVlYCwgb3JpZ2luYWwgY3NzIGhlaWdodCBpcyBwcmVzZXJ2ZWQuXG4gICAgKiAgU2hvdWxkIGJlIHVzZWQgb25seSBpZiB0aGUgdHJhbnNmb3JtYXRpb24gc3VwcG9ydHMgZGlmZmVyZW50IGFzcGVjdCByYXRpb3MuXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3VkaW5hcnlfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3VkaW5hcnlfdXBkYXRlKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRhaW5lcldpZHRoLCBkYXRhU3JjLCBtYXRjaCwgcmVmNCwgcmVxdWlyZWRXaWR0aDtcblxuICAgICAgaWYgKGVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3BvbnNpdmUgPSBvcHRpb25zLnJlc3BvbnNpdmUgIT0gbnVsbCA/IG9wdGlvbnMucmVzcG9uc2l2ZSA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlJyk7XG4gICAgICBlbGVtZW50cyA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudHMpO1xuICAgICAgdmFyIHJlc3BvbnNpdmVDbGFzcztcblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyAmJiB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSBvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm91bmREcHIgPSBvcHRpb25zLnJvdW5kX2RwciAhPSBudWxsID8gb3B0aW9ucy5yb3VuZF9kcHIgOiB0aGlzLmNvbmZpZygncm91bmRfZHByJyk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgaWYgKC9pbWcvaS50ZXN0KHRhZy50YWdOYW1lKSkge1xuICAgICAgICAgIHZhciBzZXRVcmwgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIGxvZGFzaF9hZGRDbGFzcyh0YWcsIHJlc3BvbnNpdmVDbGFzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVNyYyA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYy1jYWNoZScpIHx8IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYycpO1xuXG4gICAgICAgICAgaWYgKCFpc0VtcHR5KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZHByIGFjY29yZGluZyB0byB0aGUgZGV2aWNlJ3MgZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgZGF0YVNyYyA9IHVwZGF0ZURwci5jYWxsKF90aGlzMiwgZGF0YVNyYywgcm91bmREcHIpO1xuXG4gICAgICAgICAgICBpZiAoaHRtbHRhZy5pc1Jlc3BvbnNpdmUodGFnLCByZXNwb25zaXZlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGgodGFnKTtcblxuICAgICAgICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoL3dfYXV0bzpicmVha3BvaW50cy8udGVzdChkYXRhU3JjKSkge1xuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGNsb3VkaW5hcnlfbWF4V2lkdGgoY29udGFpbmVyV2lkdGgsIHRhZyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0bzpicmVha3BvaW50cyhbXzAtOV0qKSg6WzAtOV0rKT8vLCBcIndfYXV0bzpicmVha3BvaW50cyQxOlwiLmNvbmNhdChyZXF1aXJlZFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAvd19hdXRvKDooXFxkKykpPy8uZXhlYyhkYXRhU3JjKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggPSBhcHBseUJyZWFrcG9pbnRzLmNhbGwoX3RoaXMyLCB0YWcsIGNvbnRhaW5lcldpZHRoLCBtYXRjaFsyXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggPSBjbG91ZGluYXJ5X21heFdpZHRoKHJlcXVpcmVkV2lkdGgsIHRhZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhU3JjID0gZGF0YVNyYy5yZXBsYWNlKC93X2F1dG9bXixcXC9dKi9nLCBcIndfXCIuY29uY2F0KHJlcXVpcmVkV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnd2lkdGgnKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZXNwb25zaXZlX3ByZXNlcnZlX2hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSh0YWcsICdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIGRvZXNuJ3Qga25vdyB0aGUgc2l6ZSB5ZXQgLSB1c3VhbGx5IGJlY2F1c2UgdGhlIGltYWdlIGlzIGhpZGRlbiBvciBvdXRzaWRlIHRoZSBET00uXG4gICAgICAgICAgICAgICAgc2V0VXJsID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzTGF6eUxvYWRpbmcgPSBvcHRpb25zLmxvYWRpbmcgPT09ICdsYXp5JyAmJiAhX3RoaXMyLmlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSAmJiBfdGhpczIuaXNMYXp5TG9hZFN1cHBvcnRlZCgpICYmICFlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICBpZiAoc2V0VXJsIHx8IGlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGF0YS13aWR0aCBleGlzdHMsIHNldCB3aWR0aCB0byBiZSBkYXRhLXdpZHRoXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50c1swXSwgJ3dpZHRoJywgJ2RhdGEtd2lkdGgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldFVybCAmJiAhaXNMYXp5TG9hZGluZykge1xuICAgICAgICAgICAgICBsb2Rhc2hfc2V0QXR0cmlidXRlKHRhZywgJ3NyYycsIGRhdGFTcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBlbGVtZW50W3RvQXR0cmlidXRlXSA9IGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaWYgZWxlbWVudFtmcm9tQXR0cmlidXRlXSBpcyBzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB0b0F0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBmcm9tQXR0cmlidXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyaWJ1dGVJZkV4aXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50LCB0b0F0dHJpYnV0ZSwgZnJvbUF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoZnJvbUF0dHJpYnV0ZSk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIEludGVyc2VjdGlvbiBPYnNlcnZlciBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0xhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gd2luZG93ICYmICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdXNpbmcgQ2hyb21lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvYmplY3QsIGluaXRpYWxpemVkIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLCBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufVxuICAgICAqIEBzZWUgVHJhbnNmb3JtYXRpb25cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHNyY190cmFuc2Zvcm1hdGlvbltcIm5ld1wiXSh0aGlzLmNvbmZpZygpKS5mcm9tT3B0aW9ucyhvcHRpb25zKS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXBwZW5kIGEgVHJhbnNwYXJlbnRWaWRlbyBlbGVtZW50IHRvIHRoZSBodG1sRWxDb250YWluZXIgcGFzc2VkIHRvIGl0LlxuICAgICAqICAgICAgICAgICAgICBUcmFuc3BhcmVudFZpZGVvIGNhbiBlaXRoZXIgYmUgYW4gSFRNTCBWaWRlbyB0YWcsIG9yIGFuIEhUTUwgQ2FudmFzIFRhZy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUge0BsaW5rIFRyYW5zcGFyZW50VmlkZW9PcHRpb25zfSBvcHRpb25zIHRvIGFwcGx5IC0gRXh0ZW5kcyBUcmFuc2Zvcm1hdGlvbk9wdGlvbnNcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5wbGF5c2lubGluZSAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIHBsYXlzaW5saW5lIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zdGVyICAgICAgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBwb3N0ZXIgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wICAgICAgICAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIGxvb3AgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucz8uZXh0ZXJuYWxMaWJyYXJpZXMgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZ30gLSBtYXAgb2YgZXh0ZXJuYWwgbGlicmFyaWVzIHRvIGJlIGxvYWRlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8SFRNTEVsZW1lbnQgfCB7c3RhdHVzOnN0cmluZywgbWVzc2FnZTpzdHJpbmd9Pn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50KGh0bWxFbENvbnRhaW5lciwgcHVibGljSWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWh0bWxFbENvbnRhaW5lcikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0aW5nIGh0bWxFbENvbnRhaW5lciB0byBiZSBIVE1MRWxlbWVudCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB2aWRlb1VSTCA9IF90aGlzMy52aWRlb191cmwocHVibGljSWQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkudGhlbihmdW5jdGlvbiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG1vdW50UHJvbWlzZTtcblxuICAgICAgICAgIGlmIChpc05hdGl2ZWx5VHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIG1vdW50UHJvbWlzZSA9IHRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcoaHRtbEVsQ29udGFpbmVyLCBfdGhpczMsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW91bnRQcm9taXNlID0gdHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWcoaHRtbEVsQ29udGFpbmVyLCB2aWRlb1VSTCwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW91bnRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfcmVmLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZi5tZXNzYWdlO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBjYXRjaCBmb3IgY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KClcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZjIubWVzc2FnZTtcbiAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbG91ZGluYXJ5O1xufSgpO1xuXG5hc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSwgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbG91ZGluYXJ5ID0gKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXG4vKipcbiAqIENyZWF0ZXMgdGhlIG5hbWVzcGFjZSBmb3IgQ2xvdWRpbmFyeVxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeV9jb3JlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBDbGllbnRIaW50c01ldGFUYWc6IGNsaWVudGhpbnRzbWV0YXRhZyxcbiAgQ2xvdWRpbmFyeTogY2xvdWRpbmFyeSxcbiAgQ29uZGl0aW9uOiBjb25kaXRpb24sXG4gIENvbmZpZ3VyYXRpb246IHNyY19jb25maWd1cmF0aW9uLFxuICBjcmMzMjogc3JjX2NyYzMyLFxuICBFeHByZXNzaW9uOiBleHByZXNzaW9uLFxuICBGZXRjaExheWVyOiBmZXRjaGxheWVyLFxuICBIdG1sVGFnOiBodG1sdGFnLFxuICBJbWFnZVRhZzogaW1hZ2V0YWcsXG4gIExheWVyOiBsYXllcl9sYXllcixcbiAgUGljdHVyZVRhZzogcGljdHVyZXRhZyxcbiAgU3VidGl0bGVzTGF5ZXI6IHN1YnRpdGxlc2xheWVyLFxuICBUZXh0TGF5ZXI6IHRleHRsYXllcixcbiAgVHJhbnNmb3JtYXRpb246IHNyY190cmFuc2Zvcm1hdGlvbixcbiAgdXRmOF9lbmNvZGU6IHNyY191dGY4X2VuY29kZSxcbiAgVXRpbDogbG9kYXNoX25hbWVzcGFjZU9iamVjdCxcbiAgVmlkZW9UYWc6IHZpZGVvdGFnXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvYXNzaWduXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jbG9uZURlZXBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2NvbXBhY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9kaWZmZXJlbmNlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZnVuY3Rpb25zXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pZGVudGl0eVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pbmNsdWRlc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0FycmF5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNFbGVtZW50XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0Z1bmN0aW9uXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzU3RyaW5nXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL21lcmdlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL3RyaW1cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG91ZGluYXJ5LWNvcmUuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fd2VicGFja19leHBvcnRzX18iLCJjbGllbnRoaW50c21ldGF0YWciLCJjbG91ZGluYXJ5IiwiY29uZGl0aW9uIiwic3JjX2NvbmZpZ3VyYXRpb24iLCJzcmNfY3JjMzIiLCJleHByZXNzaW9uIiwiZmV0Y2hsYXllciIsImh0bWx0YWciLCJpbWFnZXRhZyIsImxheWVyX2xheWVyIiwicGljdHVyZXRhZyIsInN1YnRpdGxlc2xheWVyIiwidGV4dGxheWVyIiwic3JjX3RyYW5zZm9ybWF0aW9uIiwic3JjX3V0ZjhfZW5jb2RlIiwibG9kYXNoX25hbWVzcGFjZU9iamVjdCIsInZpZGVvdGFnIiwiY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCIsIlZFUlNJT04iLCJDRl9TSEFSRURfQ0ROIiwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROIiwiQUtBTUFJX1NIQVJFRF9DRE4iLCJTSEFSRURfQ0ROIiwiREVGQVVMVF9USU1FT1VUX01TIiwiREVGQVVMVF9QT1NURVJfT1BUSU9OUyIsIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTIiwiU0VPX1RZUEVTIiwiREVGQVVMVF9JTUFHRV9QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1BBUkFNUyIsIkRFRkFVTFRfVklERU9fU09VUkNFUyIsIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTIiwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMiLCJBQ0NFU1NJQklMSVRZX01PREVTIiwiVVJMX0tFWVMiLCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmUiLCJnZXRBbmFseXRpY3NPcHRpb25zIiwiYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQiLCJhIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQiLCJjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0IiwiZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0IiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0IiwiaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0IiwiaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQiLCJpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQiLCJtZXJnZV9yb290X21lcmdlX2RlZmF1bHQiLCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCIsImRldGVjdEludGVyc2VjdGlvbiIsIm9taXQiLCJiYXNldXRpbF9hbGxTdHJpbmdzIiwid2l0aG91dCIsImlzTnVtYmVyTGlrZSIsInNtYXJ0RXNjYXBlIiwiZGVmYXVsdHMiLCJvYmplY3RQcm90byIsIm9ialRvU3RyaW5nIiwiaXNPYmplY3QiLCJmdW5jVGFnIiwicmVXb3JkcyIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsImNvbnZlcnRLZXlzIiwid2l0aENhbWVsQ2FzZUtleXMiLCJ3aXRoU25ha2VDYXNlS2V5cyIsImJhc2U2NEVuY29kZSIsImJhc2U2NEVuY29kZVVSTCIsImV4dHJhY3RVcmxQYXJhbXMiLCJwYXRjaEZldGNoRm9ybWF0Iiwib3B0aW9uQ29uc3VtZSIsImlzRW1wdHkiLCJpc0FuZHJvaWQiLCJpc0VkZ2UiLCJpc0Nocm9tZSIsImlzU2FmYXJpIiwiaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQiLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0IiwidHJpbV9yb290X3RyaW1fZGVmYXVsdCIsImxvZGFzaF9nZXREYXRhIiwibG9kYXNoX3NldERhdGEiLCJsb2Rhc2hfZ2V0QXR0cmlidXRlIiwibG9kYXNoX3NldEF0dHJpYnV0ZSIsImxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwibG9kYXNoX2hhc0NsYXNzIiwibG9kYXNoX2FkZENsYXNzIiwiZ2V0U3R5bGVzIiwiY3NzRXhwYW5kIiwiZG9tU3R5bGUiLCJjdXJDU1MiLCJjc3NWYWx1ZSIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZ2V0V2lkdGhPckhlaWdodCIsImxvZGFzaF93aWR0aCIsInV0ZjhfZW5jb2RlIiwiYXJnU3RyaW5nIiwiYzEiLCJlbmMiLCJlbmQiLCJzdGFydCIsInN0cmluZyIsInN0cmluZ2wiLCJ1dGZ0ZXh0IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNsaWNlIiwiY3JjMzIiLCJzdHIiLCJjcmMiLCJpVG9wIiwidGFibGUiLCJ4IiwieSIsInN1YnN0ciIsInN0cmluZ1BhZCIsInRhcmdldExlbmd0aCIsInBhZFN0cmluZyIsInJlcGVhdFN0cmluZ051bVRpbWVzIiwidGltZXMiLCJyZXBlYXRlZFN0cmluZyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbiIsImFycjIiLCJjaGFycyIsImJhc2U2NE1hcF9udW0iLCJtYXAiLCJmb3JFYWNoIiwiX2NoYXIiLCJiYXNlNjRNYXAiLCJyZXZlcnNlVmVyc2lvbiIsInNlbVZlciIsInNwbGl0IiwiRXJyb3IiLCJyZXZlcnNlIiwic2VnbWVudCIsImpvaW4iLCJlbmNvZGVWZXJzaW9uIiwic3RyUmVzdWx0IiwicGFydHMiLCJwYWRkZWRTdHJpbmdMZW5ndGgiLCJwYWRkZWRSZXZlcnNlZFNlbXZlciIsIm51bSIsInBhcnNlSW50IiwicGFkZGVkQmluYXJ5IiwibWF0Y2giLCJiaXRTdHJpbmciLCJhbmFseXRpY3NPcHRpb25zIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidHdvUGFydFZlcnNpb24iLCJyZW1vdmVQYXRjaEZyb21TZW12ZXIiLCJ0ZWNoVmVyc2lvbiIsImVuY29kZWRTREtWZXJzaW9uIiwic2RrU2VtdmVyIiwiZW5jb2RlZFRlY2hWZXJzaW9uIiwiZmVhdHVyZUNvZGUiLCJmZWF0dXJlIiwiU0RLQ29kZSIsInNka0NvZGUiLCJhbGdvVmVyc2lvbiIsImNvbmNhdCIsImUiLCJzZW1WZXJTdHIiLCJvcHRpb25zIiwidXJsQW5hbHl0aWNzIiwiYWNjZXNzaWJpbGl0eSIsImxvYWRpbmciLCJyZXNwb25zaXZlIiwicGxhY2Vob2xkZXIiLCJhc3NpZ25fcm9vdF9hc3NpZ25fIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyIsImNvbXBhY3Rfcm9vdF9jb21wYWN0XyIsImRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18iLCJpZGVudGl0eV9yb290X2lkZW50aXR5XyIsImluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfIiwiaXNBcnJheV9yb290X2lzQXJyYXlfIiwiaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfIiwiaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18iLCJtZXJnZV9yb290X21lcmdlXyIsImlzRWxlbWVudF9yb290X2lzRWxlbWVudF8iLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8iLCJ0cmltX3Jvb3RfdHJpbV8iLCJfdHlwZW9mIiwib2JqIiwid2luZG93IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJIVE1MSW1hZ2VFbGVtZW50IiwiZWwiLCJvbkludGVyc2VjdCIsIm9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJ1bm9ic2VydmUiLCJ0YXJnZXQiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwiZm9ybWF0IiwicmVzb3VyY2VfdHlwZSIsInRyYW5zZm9ybWF0aW9uIiwidHlwZSIsImZhbGxiYWNrX2NvbnRlbnQiLCJzb3VyY2VfdHJhbnNmb3JtYXRpb24iLCJzb3VyY2VfdHlwZXMiLCJjb2RlY3MiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJ2aWRlb19jb2RlYyIsInNlZVRocnUiLCJlZmZlY3QiLCJxdWFsaXR5IiwiZmV0Y2hfZm9ybWF0Iiwid2lkdGgiLCJhc3BlY3RfcmF0aW8iLCJjcm9wIiwiYmFja2dyb3VuZCIsImhlaWdodCIsImdyYXZpdHkiLCJ2YXJpYWJsZXMiLCJkYXJrbW9kZSIsImJyaWdodG1vZGUiLCJtb25vY2hyb21lIiwiY29sb3JibGluZCIsImJhc2V1dGlsX3R5cGVvZiIsImtleXMiLCJzcmNLZXlzIiwiZmlsdGVyIiwiZmlsdGVyZWQiLCJhbGxTdHJpbmdzIiwibGlzdCIsImV2ZXJ5IiwiYXJyYXkiLCJpdGVtIiwidiIsImlzTmFOIiwicGFyc2VGbG9hdCIsInVuc2FmZSIsInJlcGxhY2UiLCJ0b1VwcGVyQ2FzZSIsImRlc3RpbmF0aW9uIiwiX2xlbiIsInNvdXJjZXMiLCJfa2V5IiwicmVkdWNlIiwiZGVzdCIsInNvdXJjZSIsImlzRnVuY3Rpb24iLCJsb3dlciIsInVwcGVyIiwiUmVnRXhwIiwid29yZHMiLCJ3b3JkIiwiY2hhckF0IiwidG9Mb2NhbGVVcHBlckNhc2UiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImNvbnZlcnRlciIsInJlc3VsdCIsImJ0b2EiLCJCdWZmZXIiLCJpbnB1dCIsInVybCIsImRlY29kZVVSSSIsImVuY29kZVVSSSIsIm9wdGlvbl9uYW1lIiwiZGVmYXVsdF92YWx1ZSIsInNpemUiLCJnZXRVc2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJub2RlQ29udGFpbnMiLCJnZXREYXRhIiwiZWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImdldEF0dHIiLCJkYXRhIiwialF1ZXJ5IiwiZm4iLCJzZXREYXRhIiwic2V0QXR0cmlidXRlIiwic2V0QXR0ciIsImF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzIiwicmVzdWx0cyIsInB1c2giLCJoYXNDbGFzcyIsImNsYXNzTmFtZSIsImFkZENsYXNzIiwiZWxlbSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIm9wZW5lciIsImdldENvbXB1dGVkU3R5bGUiLCJiIiwiYWRvd24iLCJidXAiLCJub2RlVHlwZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJjb250YWlucyIsInN0eWxlIiwiY29tcHV0ZWQiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwicmV0Iiwicm1hcmdpbiIsImdldFByb3BlcnR5VmFsdWUiLCJybnVtbm9ucHgiLCJjb252ZXJ0Iiwic3R5bGVzIiwidmFsIiwiZXh0cmEiLCJpc0JvcmRlckJveCIsInNpZGUiLCJzaWRlcyIsInBudW0iLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIkV4cHJlc3Npb24iLCJleHByZXNzaW9uU3RyIiwiZXhwcmVzc2lvbnMiLCJub3JtYWxpemUiLCJzZXJpYWxpemUiLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJzZXRQYXJlbnQiLCJwcmVkaWNhdGUiLCJvcGVyYXRvciIsIk9QRVJBVE9SUyIsImFuZCIsIm9yIiwidGhlbiIsImFzcGVjdFJhdGlvIiwicGFnZUNvdW50IiwiZmFjZUNvdW50IiwiX3ZhbHVlIiwiX25ldyIsIm9wZXJhdG9ycyIsIm9wZXJhdG9yc1BhdHRlcm4iLCJvcGVyYXRvcnNSZXBsYWNlUkUiLCJwcmVkZWZpbmVkVmFyc1BhdHRlcm4iLCJQUkVERUZJTkVEX1ZBUlMiLCJ1c2VyVmFyaWFibGVQYXR0ZXJuIiwidmFyaWFibGVzUmVwbGFjZVJFIiwidmFyaWFibGUiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0IiwiaW5pdGlhbEFzcGVjdFJhdGlvIiwiY3VycmVudFBhZ2UiLCJ0YWdzIiwicGFnZVgiLCJwYWdlWSIsIkJPVU5EUlkiLCJjb25kaXRpb25fdHlwZW9mIiwiY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25kaXRpb25fY3JlYXRlQ2xhc3MiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJfc2V0UHJvdG90eXBlT2YiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImdldFByb3RvdHlwZU9mIiwiQ29uZGl0aW9uIiwiX0V4cHJlc3Npb24iLCJfc3VwZXIiLCJjb25kaXRpb25TdHIiLCJkdXJhdGlvbiIsImluaXRpYWxEdXJhdGlvbiIsIl9zbGljZWRUb0FycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJkb25lIiwiZXJyIiwiY29uZmlndXJhdGlvbl9jbGFzc0NhbGxDaGVjayIsImNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MiLCJjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24iLCJDb25maWd1cmF0aW9uIiwiY29uZmlndXJhdGlvbiIsIkRFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMiLCJpbml0IiwiZnJvbUVudmlyb25tZW50IiwiZnJvbURvY3VtZW50Iiwic2V0IiwibWVyZ2UiLCJjb25maWciLCJtZXRhX2VsZW1lbnRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX3RoaXMiLCJjbG91ZGluYXJ5X3VybCIsInF1ZXJ5IiwidXJpIiwidXJpUmVnZXgiLCJwcm9jZXNzIiwiZW52IiwiQ0xPVURJTkFSWV9VUkwiLCJleGVjIiwiX3ZhbHVlJHNwbGl0IiwiX3ZhbHVlJHNwbGl0MiIsImsiLCJuZXdfY29uZmlnIiwibmV3X3ZhbHVlIiwidG9PcHRpb25zIiwicmVzcG9uc2l2ZV9jbGFzcyIsInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIiwicm91bmRfZHByIiwic2VjdXJlIiwibG9jYXRpb24iLCJwcm90b2NvbCIsIkNPTkZJR19QQVJBTVMiLCJsYXllcl9jbGFzc0NhbGxDaGVjayIsImxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJsYXllcl9jcmVhdGVDbGFzcyIsImxheWVyX0xheWVyIiwiTGF5ZXIiLCJyZWYiLCJyZXNvdXJjZVR5cGUiLCJwdWJsaWNJZCIsImdldFB1YmxpY0lkIiwiZ2V0RnVsbFB1YmxpY0lkIiwiY29tcG9uZW50cyIsImNsb25lIiwidGV4dGxheWVyX3R5cGVvZiIsInRleHRsYXllcl9jbGFzc0NhbGxDaGVjayIsInRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwidGV4dGxheWVyX2NyZWF0ZUNsYXNzIiwidGV4dGxheWVyX2luaGVyaXRzIiwidGV4dGxheWVyX3NldFByb3RvdHlwZU9mIiwidGV4dGxheWVyX2NyZWF0ZVN1cGVyIiwidGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInRleHRsYXllcl9nZXRQcm90b3R5cGVPZiIsInRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInRleHRsYXllcl9UZXh0TGF5ZXIiLCJfTGF5ZXIiLCJUZXh0TGF5ZXIiLCJfcmVzb3VyY2VUeXBlIiwiX3R5cGUiLCJfZm9ybWF0IiwiZm9udEZhbWlseSIsIl9mb250RmFtaWx5IiwiZm9udFNpemUiLCJfZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2ZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJfZm9udFN0eWxlIiwidGV4dERlY29yYXRpb24iLCJfdGV4dERlY29yYXRpb24iLCJ0ZXh0QWxpZ24iLCJfdGV4dEFsaWduIiwic3Ryb2tlIiwiX3N0cm9rZSIsImxldHRlclNwYWNpbmciLCJfbGV0dGVyU3BhY2luZyIsImxpbmVTcGFjaW5nIiwiX2xpbmVTcGFjaW5nIiwiZm9udEhpbnRpbmciLCJfZm9udEhpbnRpbmciLCJmb250QW50aWFsaWFzaW5nIiwiX2ZvbnRBbnRpYWxpYXNpbmciLCJ0ZXh0IiwiX3RleHQiLCJ0ZXh0U3R5bGUiLCJfdGV4dFN0eWxlIiwiaGFzUHVibGljSWQiLCJoYXNTdHlsZSIsInJlIiwicmVzIiwidGV4dFNvdXJjZSIsInRleHRTdHlsZUlkZW50aWZpZXIiLCJpbmRleCIsInVuc2hpZnQiLCJzdWJ0aXRsZXNsYXllcl90eXBlb2YiLCJzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwic3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MiLCJzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayIsInN1YnRpdGxlc2xheWVyX2luaGVyaXRzIiwic3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJzdWJ0aXRsZXNsYXllcl9jcmVhdGVTdXBlciIsInN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mIiwic3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlN1YnRpdGxlc0xheWVyIiwiX1RleHRMYXllciIsImZldGNobGF5ZXJfdHlwZW9mIiwiZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayIsImZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsImZldGNobGF5ZXJfY3JlYXRlQ2xhc3MiLCJmZXRjaGxheWVyX2luaGVyaXRzIiwiZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZiIsImZldGNobGF5ZXJfY3JlYXRlU3VwZXIiLCJmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImZldGNobGF5ZXJfRmV0Y2hMYXllciIsIkZldGNoTGF5ZXIiLCJfdXJsIiwicGFyYW1ldGVyc190eXBlb2YiLCJfZ2V0IiwicmVjZWl2ZXIiLCJiYXNlIiwiX3N1cGVyUHJvcEJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiIsInBhcmFtZXRlcnNfaW5oZXJpdHMiLCJwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mIiwicGFyYW1ldGVyc19jcmVhdGVTdXBlciIsInBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwicGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwicGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrIiwicGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzIiwicGFyYW1ldGVyc19jcmVhdGVDbGFzcyIsInBhcmFtZXRlcnNfUGFyYW0iLCJQYXJhbSIsInNob3J0TmFtZSIsIm9yaWdWYWx1ZSIsInZhbGlkIiwibm9ybV9jb2xvciIsImJ1aWxkX2FycmF5IiwiYXJnIiwicHJvY2Vzc192aWRlb19wYXJhbXMiLCJwYXJhbSIsInZpZGVvIiwiY29kZWMiLCJwcm9maWxlIiwibGV2ZWwiLCJiX2ZyYW1lcyIsInBhcmFtZXRlcnNfQXJyYXlQYXJhbSIsIl9QYXJhbSIsIkFycmF5UGFyYW0iLCJzZXAiLCJhcnJheVZhbHVlIiwiZmxhdCIsIl90aGlzMiIsInBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSIsIl9QYXJhbTIiLCJUcmFuc2Zvcm1hdGlvblBhcmFtIiwiX3N1cGVyMiIsIl90aGlzMyIsIl90aGlzNCIsImpvaW5lZCIsIm9yaWdWYWx1ZTEiLCJudW1iZXJfcGF0dGVybiIsIm9mZnNldF9hbnlfcGF0dGVybiIsInBhcmFtZXRlcnNfUmFuZ2VQYXJhbSIsIl9QYXJhbTMiLCJSYW5nZVBhcmFtIiwiX3N1cGVyMyIsIm5vcm1fcmFuZ2VfdmFsdWUiLCJvZmZzZXQiLCJtb2RpZmllciIsInBhcmFtZXRlcnNfUmF3UGFyYW0iLCJfUGFyYW00IiwiUmF3UGFyYW0iLCJfc3VwZXI0IiwicGFyYW1ldGVyc19MYXllclBhcmFtIiwiX1BhcmFtNSIsIkxheWVyUGFyYW0iLCJfc3VwZXI1IiwibGF5ZXJPcHRpb25zIiwibGF5ZXIiLCJwYXJhbWV0ZXJzX0V4cHJlc3Npb25QYXJhbSIsIl9QYXJhbTYiLCJFeHByZXNzaW9uUGFyYW0iLCJfc3VwZXI2IiwidHJhbnNmb3JtYXRpb25fdHlwZW9mIiwidHJhbnNmb3JtYXRpb25faW5oZXJpdHMiLCJ0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiIsInRyYW5zZm9ybWF0aW9uX2NyZWF0ZVN1cGVyIiwidHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YiLCJ0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzIiwidHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQiLCJ0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCIsInRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayIsInRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJ0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyIsImFzc2lnbk5vdE51bGwiLCJ0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbkJhc2UiLCJ0cmFucyIsIndpdGhDaGFpbiIsIm9wdCIsIm90aGVyT3B0aW9ucyIsImNoYWluZWQiLCJ0ciIsImZyb21PcHRpb25zIiwiYWJiciIsImRlZmF1bHRWYWx1ZSIsInJhd1BhcmFtIiwibGFzdEFyZ0NhbGxiYWNrIiwicmFuZ2VQYXJhbSIsImFycmF5UGFyYW0iLCJ0cmFuc2Zvcm1hdGlvblBhcmFtIiwibGF5ZXJQYXJhbSIsImdldFZhbHVlIiwicmVtb3ZlIiwidGVtcCIsIlZBUl9OQU1FX1JFIiwic29ydCIsInRvUGxhaW5PYmplY3QiLCJoYXNoIiwiY2hhaW4iLCJuYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZXNldFRyYW5zZm9ybWF0aW9ucyIsImZyb21UcmFuc2Zvcm1hdGlvbiIsIm90aGVyIiwiY2FtZWxLZXkiLCJfbGVuMiIsInZhbHVlcyIsIl9rZXkyIiwidHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24iLCJtZXRob2RzIiwiaGFzTGF5ZXIiLCJpZlBhcmFtIiwiaiIsInBhcmFtTGlzdCIsInJlZjEiLCJyZWYyIiwicmVmMyIsInJlZjQiLCJyZXN1bHRBcnJheSIsInRyYW5zZm9ybWF0aW9uTGlzdCIsInRyYW5zZm9ybWF0aW9uU3RyaW5nIiwidmFycyIsInByb2Nlc3NWYXIiLCJsZW4xIiwicGFyYW1fc2VwYXJhdG9yIiwidHJhbnNfc2VwYXJhdG9yIiwidG9IdG1sQXR0cmlidXRlcyIsImF0dHJOYW1lIiwic25ha2VDYXNlS2V5IiwiUEFSQU1fTkFNRVMiLCJ0b0h0bWwiLCJsaXN0TmFtZXMiLCJpc1ZhbGlkUGFyYW1OYW1lIiwiaW5kZXhPZiIsImFyZ3MiLCJjYWxsYmFjayIsInZhckFycmF5IiwiX3ZhckFycmF5JGoiLCJwcm9jZXNzQ3VzdG9tRnVuY3Rpb24iLCJfcmVmIiwiZnVuY3Rpb25fdHlwZSIsIl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbiIsImFuZ2xlIiwiYXVkaW9Db2RlYyIsImF1ZGlvRnJlcXVlbmN5IiwiYml0UmF0ZSIsImJvcmRlciIsImNvbG9yIiwiY29sb3JTcGFjZSIsImN1c3RvbUZ1bmN0aW9uIiwiY3VzdG9tUHJlRnVuY3Rpb24iLCJkZWZhdWx0SW1hZ2UiLCJkZWxheSIsImRlbnNpdHkiLCJkcHIiLCJfZWxzZSIsImVuZElmIiwiZW5kT2Zmc2V0IiwiZmFsbGJhY2tDb250ZW50IiwiZmV0Y2hGb3JtYXQiLCJmbGFncyIsImZwcyIsImh0bWxIZWlnaHQiLCJodG1sV2lkdGgiLCJfaWYiLCJpZlZhbCIsInRySWYiLCJ0clJlc3QiLCJrZXlmcmFtZUludGVydmFsIiwib2NyIiwiZW5kX28iLCJzdGFydF9vIiwiX3JlZjIiLCJfcmVmMyIsInN0YXJ0T2Zmc2V0Iiwib3BhY2l0eSIsIm92ZXJsYXkiLCJwYWdlIiwicG9zdGVyIiwicHJlZml4IiwicmFkaXVzIiwicmF3VHJhbnNmb3JtYXRpb24iLCJzb3VyY2VUeXBlcyIsInNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic3RyZWFtaW5nUHJvZmlsZSIsInVuZGVybGF5IiwidmlkZW9Db2RlYyIsInZpZGVvU2FtcGxpbmciLCJ6b29tIiwiaHRtbHRhZ19jbGFzc0NhbGxDaGVjayIsImh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyIsImh0bWx0YWdfY3JlYXRlQ2xhc3MiLCJodG1sdGFnX0h0bWxUYWciLCJIdG1sVGFnIiwiaHRtbEF0dHJzIiwiYXR0cnMiLCJwYWlycyIsImVzY2FwZVF1b3RlcyIsImh0bWx0YWdfdG9BdHRyaWJ1dGUiLCJnZXRPcHRpb25zIiwiZ2V0T3B0aW9uIiwiaHRtbEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyIiwiY29udGVudCIsIm9wZW5UYWciLCJ0YWciLCJjbG9zZVRhZyIsInRvRE9NIiwiY3JlYXRlRWxlbWVudCIsImlzUmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVDbGFzcyIsImRhdGFTcmMiLCJfZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsIm1ha2VVcmwiLCJob3N0IiwicGF0aG5hbWUiLCJpc1VybCIsImNkblN1YmRvbWFpbk51bWJlciIsImhhbmRsZVNpZ25hdHVyZSIsInNpZ25hdHVyZSIsImlzRm9ybWF0dGVkIiwiaGFuZGxlUHJlZml4IiwiY2xvdWRfbmFtZSIsImNkblBhcnQiLCJzdWJkb21haW4iLCJwYXRoIiwicHJpdmF0ZV9jZG4iLCJjZG5fc3ViZG9tYWluIiwic2VjdXJlX2Nkbl9zdWJkb21haW4iLCJzZWN1cmVfZGlzdHJpYnV0aW9uIiwiY25hbWUiLCJoYW5kbGVSZXNvdXJjZVR5cGUiLCJfcmVmJHJlc291cmNlX3R5cGUiLCJfcmVmJHR5cGUiLCJ1cmxfc3VmZml4IiwidXNlX3Jvb3RfcGF0aCIsInNob3J0ZW4iLCJlbmNvZGVQdWJsaWNJZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZvcm1hdFB1YmxpY0lkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJ0cnVzdF9wdWJsaWNfaWQiLCJ2YWxpZGF0ZSIsImhhbmRsZVZlcnNpb24iLCJpc0ZvcmNlVmVyc2lvbiIsImZvcmNlX3ZlcnNpb24iLCJpc1ZlcnNpb25FeGlzdCIsInZlcnNpb24iLCJoYW5kbGVUcmFuc2Zvcm1hdGlvbiIsInBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zIiwiYmx1ciIsInByZXBhcmVQdWJsaWNJZCIsInVybFN0cmluZyIsInByZXBhcmVPcHRpb25zIiwidXJsX3VybCIsInJlc3VsdFVybCIsInNka0FuYWx5dGljc1NpZ25hdHVyZSIsImFwcGVuZGVyIiwiYXV0aF90b2tlbiIsIl9hcHBlbmRlciIsImdlbmVyYXRlQnJlYWtwb2ludHNfc2xpY2VkVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHNfbm9uSXRlcmFibGVSZXN0IiwiZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50cyIsInNyY3NldCIsImJyZWFrcG9pbnRzIiwiX21hcCIsIm1pbl93aWR0aCIsIm1heF93aWR0aCIsIm1heF9pbWFnZXMiLCJOdW1iZXIiLCJfbWFwMiIsInNvbWUiLCJzdGVwU2l6ZSIsIk1hdGgiLCJjZWlsIiwibWF4IiwiY3VycmVudCIsInNyY3NldFV0aWxzX2lzRW1wdHkiLCJzY2FsZWRVcmwiLCJwdWJsaWNfaWQiLCJjb25maWdQYXJhbXMiLCJyYXdfdHJhbnNmb3JtYXRpb24iLCJnZXRPckdlbmVyYXRlQnJlYWtwb2ludHMiLCJnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZSIsImdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUiLCJnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXMiLCJzcmNzZXREYXRhIiwicmVzcG9uc2l2ZUF0dHJpYnV0ZXMiLCJnZW5lcmF0ZVNpemVzIiwic2l6ZXMiLCJnZW5lcmF0ZVNyY3NldCIsInNyY3NldEF0dHIiLCJzaXplc0F0dHIiLCJnZW5lcmF0ZU1lZGlhQXR0ciIsIm1lZGlhUXVlcnkiLCJzcmNzZXRVcmwiLCJpbWFnZXRhZ190eXBlb2YiLCJpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayIsImltYWdldGFnX2RlZmluZVByb3BlcnRpZXMiLCJpbWFnZXRhZ19jcmVhdGVDbGFzcyIsImltYWdldGFnX2dldCIsImltYWdldGFnX3N1cGVyUHJvcEJhc2UiLCJpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiIsImltYWdldGFnX2luaGVyaXRzIiwiaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19jcmVhdGVTdXBlciIsImltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJpbWFnZXRhZ19JbWFnZVRhZyIsIl9IdG1sVGFnIiwiSW1hZ2VUYWciLCJzcmNBdHRyaWJ1dGUiLCJzcmNzZXRQYXJhbSIsImNsaWVudF9oaW50cyIsInNvdXJjZXRhZ190eXBlb2YiLCJzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyIsInNvdXJjZXRhZ19jcmVhdGVDbGFzcyIsInNvdXJjZXRhZ19nZXQiLCJzb3VyY2V0YWdfc3VwZXJQcm9wQmFzZSIsInNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19pbmhlcml0cyIsInNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19jcmVhdGVTdXBlciIsInNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzb3VyY2V0YWdfU291cmNlVGFnIiwiU291cmNlVGFnIiwibWVkaWEiLCJzb3VyY2V0YWciLCJwaWN0dXJldGFnX3R5cGVvZiIsInBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2siLCJwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMiLCJwaWN0dXJldGFnX2NyZWF0ZUNsYXNzIiwicGljdHVyZXRhZ19nZXQiLCJwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2UiLCJwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19pbmhlcml0cyIsInBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YiLCJwaWN0dXJldGFnX2NyZWF0ZVN1cGVyIiwicGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInBpY3R1cmV0YWdfUGljdHVyZVRhZyIsIlBpY3R1cmVUYWciLCJ3aWR0aExpc3QiLCJ2aWRlb3RhZ190eXBlb2YiLCJ2aWRlb3RhZ19jbGFzc0NhbGxDaGVjayIsInZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMiLCJ2aWRlb3RhZ19jcmVhdGVDbGFzcyIsInZpZGVvdGFnX2dldCIsInZpZGVvdGFnX3N1cGVyUHJvcEJhc2UiLCJ2aWRlb3RhZ19nZXRQcm90b3R5cGVPZiIsInZpZGVvdGFnX2luaGVyaXRzIiwidmlkZW90YWdfc2V0UHJvdG90eXBlT2YiLCJ2aWRlb3RhZ19jcmVhdGVTdXBlciIsInZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJWSURFT19UQUdfUEFSQU1TIiwidmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TIiwidmlkZW90YWdfVmlkZW9UYWciLCJWaWRlb1RhZyIsInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic2V0U291cmNlVHlwZXMiLCJzZXRQb3N0ZXIiLCJzZXRGYWxsYmFja0NvbnRlbnQiLCJmYWxsYmFjayIsImlubmVyVGFncyIsInNyYyIsImNyZWF0ZVNvdXJjZVRhZyIsInNyY1R5cGUiLCJkZWZhdWx0T3B0aW9ucyIsImhhc1NvdXJjZVRhZ3MiLCJzb3VyY2VUeXBlIiwibWltZVR5cGUiLCJ2aWRlb1R5cGUiLCJjb2RlY3NTdHIiLCJjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mIiwiY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrIiwiY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMiLCJjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlQ2xhc3MiLCJjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMiLCJjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlU3VwZXIiLCJjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mIiwiY2xpZW50aGludHNtZXRhdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyIsIkNsaWVudEhpbnRzTWV0YVRhZyIsIm5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzIiwibm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJlbGVtZW50cyIsIm1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnIiwiaHRtbEVsQ29udGFpbmVyIiwiY2xJbnN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW5uZXJIVE1MIiwidmlkZW9UYWciLCJjbG91ZGluYXJ5VmlkZW9FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJhZGRGbGFnVG9PcHRpb25zIiwiZmxhZyIsImFkZEZsYWciLCJlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJhdXRvcGxheSIsIm11dGVkIiwiY29udHJvbHMiLCJtYXhfdGltZW91dF9tcyIsImV4dGVybmFsTGlicmFyaWVzIiwidHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJsb2FkU2NyaXB0Iiwic2NyaXB0VVJMIiwiaXNBbHJlYWR5TG9hZGVkIiwic2NyaXB0VGFnIiwidGltZXJJRCIsInNldFRpbWVvdXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwib25lcnJvciIsImNsZWFyVGltZW91dCIsIm9ubG9hZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInhocl9sb2FkU2NyaXB0IiwicmVqZWN0T25UaW1lb3V0IiwibWF4VGltZW91dE1TIiwiZ2V0QmxvYkZyb21VUkwiLCJ1cmxUb0xvYWQiLCJmZXRjaEJsb2IiLCJmZXRjaCIsImxvYWRVcmxVc2luZ0ZldGNoIiwibG9hZFVybFVzaW5nWGhyIiwiYmxvYiIsInBheWxvYWQiLCJibG9iVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmVzcG9uc2UiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInJlc3BvbnNlVHlwZSIsIm9wZW4iLCJzZW5kIiwieGhyX2dldEJsb2JGcm9tVVJMIiwiY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJ2aWRlb09wdGlvbnMiLCJwbGF5c2lubGluZSIsImxvb3AiLCJ2aWRlb1VSTCIsInZpc2liaWxpdHkiLCJwb3NpdGlvbiIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJpbnN0YW50aWF0ZVNlZVRocnUiLCJ2aWRlb0VsZW1lbnQiLCJjdXN0b21DbGFzcyIsImF1dG9QbGF5IiwiX3dpbmRvdyIsInNlZVRocnVJbnN0YW5jZSIsInJlYWR5IiwiY2FudmFzRWxlbWVudCIsImdldENhbnZhcyIsInBsYXkiLCJ0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSIsIm1vdW50U2VlVGhydUNhbnZhc1RhZyIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwiY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5IiwiY2FuUGxheSIsImNhblBsYXlUeXBlIiwidHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrIiwiY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzIiwiY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyIsImFwcGx5QnJlYWtwb2ludHMiLCJjbG9zZXN0QWJvdmUiLCJkZWZhdWx0QnJlYWtwb2ludHMiLCJjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCIsImNsb3VkaW5hcnlfbWF4V2lkdGgiLCJ1cGRhdGVEcHIiLCJzdGVwcyIsInJlc2l6aW5nIiwiY2FsY19icmVha3BvaW50IiwiZmluZENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJFbGVtZW50IiwiZGlzcGxheSIsInJvdW5kRHByIiwiZGV2aWNlX3BpeGVsX3JhdGlvIiwicmVxdWlyZWRXaWR0aCIsImltYWdlV2lkdGgiLCJjbG91ZGluYXJ5X0Nsb3VkaW5hcnkiLCJDbG91ZGluYXJ5IiwiZGV2aWNlUGl4ZWxSYXRpb0NhY2hlIiwicmVzcG9uc2l2ZUNvbmZpZyIsInJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCIsIm5ld0NvbmZpZyIsIm5ld1ZhbHVlIiwidmlkZW9fdXJsIiwidmlkZW9fdGh1bWJuYWlsX3VybCIsInRyYW5zZm9ybWF0aW9uX3N0cmluZyIsImltYWdlIiwiaW1nIiwiaW1hZ2VUYWciLCJjbG91ZGluYXJ5X3VwZGF0ZSIsInBpY3R1cmVUYWciLCJzb3VyY2VUYWciLCJ2aWRlb190aHVtYm5haWwiLCJmYWNlYm9va19wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UiLCJncmF2YXRhcl9pbWFnZSIsImZldGNoX2ltYWdlIiwic3ByaXRlX2NzcyIsImJvb3RzdHJhcCIsInJlc3BvbnNpdmVSZXNpemUiLCJ0aW1lb3V0IiwicmVzcG9uc2l2ZV9yZXNpemUiLCJtYWtlUmVzcG9uc2l2ZSIsImRlYm91bmNlIiwicmVzZXQiLCJydW4iLCJ3YWl0Iiwid2FpdEZ1bmMiLCJyZXNwb25zaXZlX2RlYm91bmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb2ludCIsImNhbGNfc3RvcHBvaW50IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRwclN0cmluZyIsInByb2Nlc3NJbWFnZVRhZ3MiLCJub2RlcyIsImltYWdlcyIsIm5vZGUiLCJ0YWdOYW1lIiwiaW1nT3B0aW9ucyIsInNldFVybCIsInJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0IiwiaXNMYXp5TG9hZGluZyIsImlzTGF6eUxvYWRTdXBwb3J0ZWQiLCJzZXRBdHRyaWJ1dGVJZkV4aXN0cyIsInRvQXR0cmlidXRlIiwiZnJvbUF0dHJpYnV0ZSIsImF0dHJpYnV0ZVZhbHVlIiwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQiLCJpc05hdGl2ZWx5VHJhbnNwYXJlbnQiLCJtb3VudFByb21pc2UiLCJjbG91ZGluYXJ5X2NvcmUiLCJVdGlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ })

};
;